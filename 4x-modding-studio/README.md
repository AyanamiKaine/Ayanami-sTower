X4 Modding Studio - Technical ArchitectureCore StackRuntime: Bun (v1.0+) - Chosen for rapid disk I/O and built-in SQLite (useful for caching).Framework: Astro - Chosen for its "Island Architecture". We can keep the main layout static and lightweight, while hydrating the complex XML Tree Viewer with Svelte.UI Library: Svelte - For the complex state management of the DOM tree.Styling: Tailwind CSS - For rapid UI development.System Components1. The Virtual File System (VFS) Layer (Server-Side)Since X4 files are distributed across 01.cat...09.cat and extensions/, the tool cannot just "open a file." It needs a VFS Resolver.Responsibility:Take a requested path: assets/units/size_xl/ship_arg_xl_carrier_01.xmlLook up the "Winner" file (using the logic we built in the C# Unpacker).Serve the content to the frontend.API Endpoints (Astro pages/api/...):GET /api/vfs/tree: Returns the full folder structure of the extracted game.GET /api/vfs/read?path=...: Returns the raw XML content of a specific file.2. The XML Engine (Shared Logic)We need a robust parser that preserves order and attributes.Library: fast-xml-parser (configured to preserve order) or native DOMParser (on client).XPath Generator: The critical algorithm. It must generate the shortest unique selector.3. The "Diff" State Machine (Client-Side)The frontend doesn't edit the XML directly; it builds a list of "Operations."State:type DiffOperation = 
  | { type: 'replace', selector: string, value: string }
  | { type: 'add', selector: string, xmlContent: string, position: 'before'|'after'|'inside' }
  | { type: 'remove', selector: string };
Output: A function that takes this state and renders the final diff.xml.Workflow for the UserSelect Base File: User browses the VFS and opens libraries/factions.xml.Visualize: The tool renders the XML as an interactive tree.Interact: User right-clicks the <relation> node for "Xenon".Action: Selects "Remove Node".Generate: The tool calculates the XPath sel="/factions/faction[@id='xenon']/relation[@faction='player']" and generates the diff code.Key XPath Rules for X4X4's XML patching engine has specific preferences:ID Priority: Always prefer [@id='...'] if available.Name Priority: Use [@name='...'] if ID is missing (common in Macros).Attribute Fallback: Use other unique attributes if needed (e.g., [@macro='...']).Positional Fallback: Use node[3] only as a last resort (brittle if the base game updates).

## TODO

The first thing we need to assign in the UI will be where the unpacked files can be found.

## Notes

Based on the technical architecture of X4's engine (Virtual File System, XML Patching, and Mission Director), the community lacks user-friendly GUI tools that abstract away the verbose XML syntax.

Here are three high-impact GUI tools you could develop to revolutionize story-mod creation, ranging from "Quality of Life" improvements to "Game Changer."

1. The "Visual Dialogue Editor" (Priority for Story Mods)
Problem: Writing branching conversations in t/conversations.xml and linking them to Mission Director (MD) scripts is tedious. You have to mentally visualize the tree structure while staring at flat XML text, managing distinct section IDs and text references manually.

Tool Concept: A node-based editor (similar to Twine or Unreal Blueprints) specifically for X4 dialogues.

GUI Workflow:

Create nodes for "NPC Says" and "Player Choice."

Drag lines between nodes to link them.

Feature: Auto-generate unique IDs for every section (e.g., c_myquest_stage1_accept) to prevent ID clashes.

Feature: A "Condition" field on connecting lines that exports the corresponding Lua/MD check (e.g., player.money > 1000).

Output: Generates two files automatically:

The conversations.xml with the correct structure.

A snippet of Mission Director code containing the <cues> that listen for the <event_conversation_next_section> signals generated by your graph.

2. The "Auto-XPath Generator" (The XML Diff Tool)
Problem: X4 relies on XML patching (diffs) rather than file replacement. Writing the XPath selectors (e.g., sel="/aiscript/attention[@min='unknown']/actions/do_if[@value='$foo']") is the single biggest barrier to entry. If you make a typo in the path, the patch fails silently.

Tool Concept: A visual "Before and After" comparison tool.

GUI Workflow:

User loads a vanilla XML file (e.g., ships.xml).

Tool displays the XML in a tree view.

User right-clicks a node (e.g., a ship's hull value) and selects "Modify," "Delete," or "Add Child."

User edits the value in a text box.

The Magic: The tool calculates the precise XPath to that specific node and generates the valid <diff><replace sel="...">...</replace></diff> file automatically.

Tech Stack: Python (using lxml library) or JavaScript (Electron) would be ideal for parsing the XML DOM and calculating paths.

3. The "Mission Director Debugger / Log Parser"
Problem: Debugging quests is painful. You have to add <debug_text> lines to your script, run the game with -logfile debuglog.txt, alt-tab out, and read a massive text file to see if your cue fired.

Tool Concept: A real-time log viewer that filters specifically for MD events.

GUI Workflow:

The tool tails the debuglog.txt file in real-time.

Visualizer: It parses the log for specific cues. If you structure your debug text (e.g., [MyMod] Cue A State: Waiting), the tool could visualize a state machine, turning nodes Green (Active) or Red (Failed) as the log updates.

Error Highlighting: Automatically highlights XML validation errors or "Cue not found" errors that the engine dumps into the log, filtering out the engine's background noise.

Technical Recommendations for Building These
Language: Python is highly recommended because the existing X4 Customizer by SirNukes is open source and written in Python. You could potentially fork it or build plugins for it, leveraging his existing code for unpacking CAT/DAT files and parsing XML.

UI Framework: Qt (via PySide/PyQt) is robust for tree views (needed for XML) and node graphs. Electron is better if you want a modern web-like interface for the Dialogue Editor.

If you want to start small, Tool #2 (Auto-XPath Generator) would likely have the highest demand from the general modding community, while Tool #1 (Visual Dialogue Editor) is essential for your specific goal of creating complex branching stories.

## Modding Guide

For more on X4 Modding take a look at the `X4 Foundations Modding Guide.md` file

## Unpacker

It can be helpful looking at the logic of the unpacker.

```
using System.Security.Cryptography;

namespace X4Unpacker
{
    class Program
    {
        private const int BufferSize = 1024 * 1024; 
        private static readonly Lock _consoleLock = new();

        static void Main(string[] args)
        {
            lock (_consoleLock) 
            {
                Console.WriteLine("X4 Foundations .cat/.dat Unpacker (Strict Deduplication)");
                Console.WriteLine("------------------------------------------------------");
            }

            string inputPath = ".";
            string outputBaseDir = "./x4_unpacked";
            bool validateHash = false;

            if (args.Length > 0) inputPath = args[0];
            if (args.Length > 1) outputBaseDir = args[1];
            if (args.Length > 2) bool.TryParse(args[2], out validateHash);

            // 1. Gather Files
            List<string> catFilesToProcess = new List<string>();
            bool isBatchMode = false;

            if (File.Exists(inputPath))
            {
                catFilesToProcess.Add(inputPath);
            }
            else if (Directory.Exists(inputPath))
            {
                isBatchMode = true;
                Console.WriteLine($"Scanning '{Path.GetFullPath(inputPath)}' for .cat files...");
                
                try 
                {
                    var files = Directory.GetFiles(inputPath, "*.cat", SearchOption.AllDirectories);
                    
                    // Sort Alphabetically to ensure correct load order (01 < 02 < ext...)
                    // This sort is CRITICAL for the "Winner-Takes-All" logic to work.
                    var sortedFiles = files
                        .Where(f => !f.EndsWith("_sig.cat", StringComparison.OrdinalIgnoreCase))
                        .OrderBy(f => f, StringComparer.OrdinalIgnoreCase) 
                        .ToList();

                    catFilesToProcess.AddRange(sortedFiles);
                }
                catch (Exception ex)
                {
                    Console.Error.WriteLine($"Error scanning directory: {ex.Message}");
                    return;
                }
            }
            else
            {
                Console.WriteLine($"Error: Input path '{inputPath}' not found.");
                return;
            }

            if (catFilesToProcess.Count == 0)
            {
                Console.WriteLine("No .cat files found to unpack.");
                return;
            }

            Console.WriteLine($"Found {catFilesToProcess.Count} catalogs.");
            Console.WriteLine($"Output Directory: {Path.GetFullPath(outputBaseDir)}");
            Console.WriteLine();

            // 2. Indexing Phase 
            Console.WriteLine("Phase 1: Indexing files to resolve collisions (Winner-Takes-All)...");
            
            // Map: FullOutputPath -> (SourceCatPath, Hash, Size, Timestamp)
            // We verify NOT JUST the catalog, but the exact file metadata to handle duplicate entries within the SAME catalog.
            Dictionary<string, (string SourceCat, string Hash, long Size, long Timestamp)> ownershipMap = 
                new Dictionary<string, (string, string, long, long)>();
            
            int indexedFiles = 0;
            foreach (var catPath in catFilesToProcess)
            {
                // Verify .dat exists before indexing. If missing, this cat cannot "Win".
                string datPath = Path.ChangeExtension(catPath, ".dat");
                if (!File.Exists(datPath)) continue;

                string specificOutputDir = outputBaseDir;
                if (isBatchMode)
                {
                    string relativeDir = Path.GetRelativePath(inputPath, Path.GetDirectoryName(catPath) ?? inputPath);
                    specificOutputDir = Path.Combine(outputBaseDir, relativeDir);
                }

                foreach (string line in File.ReadLines(catPath))
                {
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    if (TryParseCatLine(line, out CatEntry entry))
                    {
                        string fullPath = Path.Combine(specificOutputDir, entry.FilePath);
                        // Last one wins (Load Order). 
                        // If 03.cat has the same file twice, the second one overwrites the entry here.
                        ownershipMap[fullPath] = (catPath, entry.Hash, entry.Size, entry.Timestamp);
                        indexedFiles++;
                    }
                }
            }

            Console.WriteLine($"Total Entries: {indexedFiles}. Unique/Final Files: {ownershipMap.Count}");
            Console.WriteLine("Phase 2: Extracting...");
            Console.WriteLine();

            int processedCount = 0;
            int completedCount = 0;
            int totalCatalogs = catFilesToProcess.Count;

            // 3. Parallel Extraction
            // We iterate the catalogs. Inside each catalog task, we check if we own the file.
            Parallel.ForEach(catFilesToProcess, new ParallelOptions { MaxDegreeOfParallelism = Environment.ProcessorCount }, (catPath) =>
            {
                int currentIdx = Interlocked.Increment(ref processedCount);
                string displayName = isBatchMode ? Path.GetRelativePath(inputPath, catPath) : Path.GetFileName(catPath);
                string datPath = Path.ChangeExtension(catPath, ".dat");
                
                string specificOutputDir = outputBaseDir;
                if (isBatchMode)
                {
                    string relativeDir = Path.GetRelativePath(inputPath, Path.GetDirectoryName(catPath) ?? inputPath);
                    specificOutputDir = Path.Combine(outputBaseDir, relativeDir);
                }

                if (!File.Exists(datPath))
                {
                    Interlocked.Increment(ref completedCount);
                    lock (_consoleLock) Console.WriteLine($"[Skipping] {displayName} - Missing .dat");
                    return;
                }

                lock (_consoleLock) Console.WriteLine($"[{currentIdx}/{totalCatalogs}] STARTING {displayName}...");

                try
                {
                    // Pass the ownership map to the worker
                    var (extracted, skipped, masked) = ProcessCatalog(catPath, datPath, specificOutputDir, ownershipMap, validateHash);
                    
                    int finishedNow = Interlocked.Increment(ref completedCount);
                    int remaining = totalCatalogs - finishedNow;

                    lock (_consoleLock) Console.WriteLine($"[{currentIdx}/{totalCatalogs}] FINISHED {displayName} (New: {extracted}, Skipped: {skipped}, Masked: {masked}) - {remaining} left");
                }
                catch (Exception ex)
                {
                    lock (_consoleLock) Console.Error.WriteLine($"[ERROR] Failed {displayName}: {ex.Message}");
                    Interlocked.Increment(ref completedCount);
                }
            });

            Console.WriteLine("\nBatch operation complete.");
        }

        // Returns (extracted, skipped, masked)
        static (int extracted, int skipped, int masked) ProcessCatalog(string catPath, string datPath, string outputDir, Dictionary<string, (string SourceCat, string Hash, long Size, long Timestamp)> ownershipMap, bool validateHash)
        {
            int extracted = 0;
            int skipped = 0;
            int masked = 0;
            long currentOffset = 0;

            // Read lines locally to preserve sequential offset tracking
            string[] catLines = File.ReadAllLines(catPath);

            using (FileStream datStream = new FileStream(datPath, FileMode.Open, FileAccess.Read, FileShare.Read))
            {
                foreach (var line in catLines)
                {
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    if (!TryParseCatLine(line, out CatEntry entry)) continue;

                    string fullOutputPath = Path.Combine(outputDir, entry.FilePath);

                    // --- CHECK OWNERSHIP (Strict Conflict Resolution) ---
                    bool isOwner = false;
                    if (ownershipMap.TryGetValue(fullOutputPath, out var winner))
                    {
                        // To be the owner, we must match the Catalog AND the specific entry details.
                        // This handles the case where 03.cat patches itself (Line 1 vs Line 5000).
                        // Only the entry matching the "Winner" (Line 5000) will be extracted.
                        if (winner.SourceCat == catPath && 
                            winner.Hash == entry.Hash && 
                            winner.Size == entry.Size && 
                            winner.Timestamp == entry.Timestamp)
                        {
                            isOwner = true;
                        }
                    }

                    if (!isOwner)
                    {
                        // "Masked": Hidden by a newer version (in a later catalog OR later in this same catalog).
                        // We skip IO but MUST increment offset to keep alignment.
                        masked++;
                        currentOffset += entry.Size;
                        continue; 
                    }

                    // --- CHECK INCREMENTAL (UTC) ---
                    bool isUpToDate = false;
                    if (File.Exists(fullOutputPath))
                    {
                        FileInfo fi = new FileInfo(fullOutputPath);
                        if (fi.Length == entry.Size)
                        {
                            if (entry.Timestamp > 0)
                            {
                                // Valid timestamp: Check it
                                DateTime expectedUtc = DateTimeOffset.FromUnixTimeSeconds(entry.Timestamp).UtcDateTime;
                                if (Math.Abs((fi.LastWriteTimeUtc - expectedUtc).TotalSeconds) <= 2)
                                {
                                    isUpToDate = true;
                                }
                            }
                            else 
                            {
                                // If timestamp is 0 or missing, but size matches, consider it up-to-date.
                                isUpToDate = true;
                            }
                        }
                    }

                    if (isUpToDate)
                    {
                        skipped++;
                        currentOffset += entry.Size;
                        continue;
                    }

                    // --- EXTRACT ---
                    string? dir = Path.GetDirectoryName(fullOutputPath);
                    if (!string.IsNullOrEmpty(dir) && !Directory.Exists(dir)) Directory.CreateDirectory(dir);

                    ExtractFileChunk(datStream, currentOffset, entry, fullOutputPath, validateHash);
                    extracted++;
                    currentOffset += entry.Size;
                }
            }
            return (extracted, skipped, masked);
        }

        static void ExtractFileChunk(FileStream source, long offset, CatEntry entry, string destPath, bool validateHash)
        {
            source.Seek(offset, SeekOrigin.Begin);

            byte[] buffer = new byte[Math.Min(BufferSize, entry.Size)];
            long bytesRemaining = entry.Size;

            using (FileStream fsDest = new FileStream(destPath, FileMode.Create, FileAccess.Write))
            {
                if (validateHash)
                {
                    using MD5 md5 = MD5.Create();
                    using CryptoStream cs = new CryptoStream(fsDest, md5, CryptoStreamMode.Write);
                    CopyStream(source, cs, bytesRemaining, buffer);
                    cs.FlushFinalBlock();

                    string actualHash = BitConverter.ToString(md5.Hash!).Replace("-", "").ToLowerInvariant();
                    if (!string.Equals(actualHash, entry.Hash, StringComparison.OrdinalIgnoreCase))
                    {
                        lock (_consoleLock) Console.WriteLine($"\n   [HASH ERROR] {entry.FilePath} (Expected: {entry.Hash}, Got: {actualHash})");
                    }
                }
                else
                {
                    CopyStream(source, fsDest, bytesRemaining, buffer);
                }
            }

            if (entry.Timestamp > 0)
            {
                try
                {
                    // Use UTC to set time
                    DateTime dt = DateTimeOffset.FromUnixTimeSeconds(entry.Timestamp).UtcDateTime;
                    File.SetLastWriteTimeUtc(destPath, dt);
                }
                catch 
                {
                    // If setting time fails (permissions/FS issues), we just ignore it.
                    // The file will just have the current time.
                }
            }
        }

        static void CopyStream(Stream input, Stream output, long bytesToCopy, byte[] buffer)
        {
            while (bytesToCopy > 0)
            {
                int bytesToRead = (int)Math.Min(buffer.Length, bytesToCopy);
                int bytesRead = input.Read(buffer, 0, bytesToRead);
                if (bytesRead == 0) break; 
                output.Write(buffer, 0, bytesRead);
                bytesToCopy -= bytesRead;
            }
        }

        static bool TryParseCatLine(string line, out CatEntry entry)
        {
            entry = new CatEntry();
            string[] tokens = line.Split(' ');
            if (tokens.Length < 4) return false;

            entry.Hash = tokens[^1];
            if (!long.TryParse(tokens[^2], out long timestamp)) return false;
            entry.Timestamp = timestamp;
            if (!long.TryParse(tokens[^3], out long size)) return false;
            entry.Size = size;
            entry.FilePath = string.Join(" ", tokens.Take(tokens.Length - 3));
            return true;
        }
    }

    struct CatEntry
    {
        public string FilePath;
        public long Size;
        public long Timestamp;
        public string Hash;
    }
}
```