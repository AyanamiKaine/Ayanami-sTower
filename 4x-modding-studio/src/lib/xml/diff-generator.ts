/**
 * X4 Diff XML Generator
 * 
 * Generates valid diff.xml files following X4's XML patching format.
 * Supports: replace, add, remove operations
 */

import type { XMLNode } from './parser';
import { serializeNode } from './parser';

export type DiffOperationType = 'replace' | 'add' | 'remove';
export type AddPosition = 'before' | 'after' | 'prepend' | 'append';

export interface DiffOperation {
    id: string;
    type: DiffOperationType;
    selector: string;
    targetNode?: XMLNode;
    // For replace
    newValue?: string;
    // For add
    xmlContent?: string;
    position?: AddPosition;
    // Metadata
    description?: string;
    confidence: 'high' | 'medium' | 'low';
    warning?: string;
}

export interface DiffState {
    operations: DiffOperation[];
    sourceFile: string;
}

let operationCounter = 0;

export function createDiffState(sourceFile: string): DiffState {
    return {
        operations: [],
        sourceFile,
    };
}

export function addOperation(state: DiffState, operation: Omit<DiffOperation, 'id'>): DiffState {
    return {
        ...state,
        operations: [
            ...state.operations,
            { ...operation, id: `op_${++operationCounter}` },
        ],
    };
}

export function removeOperation(state: DiffState, operationId: string): DiffState {
    return {
        ...state,
        operations: state.operations.filter(op => op.id !== operationId),
    };
}

export function updateOperation(
    state: DiffState,
    operationId: string,
    updates: Partial<DiffOperation>
): DiffState {
    return {
        ...state,
        operations: state.operations.map(op =>
            op.id === operationId ? { ...op, ...updates } : op
        ),
    };
}

/**
 * Generate the final diff.xml content
 */
export function generateDiffXML(state: DiffState): string {
    const lines: string[] = [
        '<?xml version="1.0" encoding="utf-8"?>',
        '<!--',
        `  Generated by X4 Modding Studio`,
        `  Source: ${state.sourceFile}`,
        `  Operations: ${state.operations.length}`,
        '-->',
        '<diff>',
    ];

    for (const op of state.operations) {
        lines.push('');
        if (op.description) {
            lines.push(`  <!-- ${op.description} -->`);
        }
        if (op.warning) {
            lines.push(`  <!-- WARNING: ${op.warning} -->`);
        }

        switch (op.type) {
            case 'replace':
                lines.push(...generateReplaceElement(op));
                break;
            case 'add':
                lines.push(...generateAddElement(op));
                break;
            case 'remove':
                lines.push(...generateRemoveElement(op));
                break;
        }
    }

    lines.push('');
    lines.push('</diff>');

    return lines.join('\n');
}

function generateReplaceElement(op: DiffOperation): string[] {
    const lines: string[] = [];

    // Check if we're replacing an attribute value or element content
    if (op.selector.includes('/@')) {
        // Attribute replacement
        lines.push(`  <replace sel="${escapeAttr(op.selector)}">${escapeXML(op.newValue || '')}</replace>`);
    } else if (op.newValue !== undefined) {
        // Simple value replacement
        lines.push(`  <replace sel="${escapeAttr(op.selector)}">${escapeXML(op.newValue)}</replace>`);
    } else if (op.xmlContent) {
        // Full element replacement
        const content = indentContent(op.xmlContent, 4);
        lines.push(`  <replace sel="${escapeAttr(op.selector)}">`);
        lines.push(content);
        lines.push('  </replace>');
    }

    return lines;
}

function generateAddElement(op: DiffOperation): string[] {
    const lines: string[] = [];
    const content = indentContent(op.xmlContent || '', 4);

    switch (op.position) {
        case 'before':
            lines.push(`  <add sel="${escapeAttr(op.selector)}" pos="before">`);
            break;
        case 'after':
            lines.push(`  <add sel="${escapeAttr(op.selector)}" pos="after">`);
            break;
        case 'prepend':
            lines.push(`  <add sel="${escapeAttr(op.selector)}" pos="prepend">`);
            break;
        case 'append':
        default:
            lines.push(`  <add sel="${escapeAttr(op.selector)}">`);
            break;
    }

    lines.push(content);
    lines.push('  </add>');

    return lines;
}

function generateRemoveElement(op: DiffOperation): string[] {
    return [`  <remove sel="${escapeAttr(op.selector)}" />`];
}

function escapeAttr(str: string): string {
    return str.replace(/"/g, '&quot;').replace(/&/g, '&amp;');
}

function escapeXML(str: string): string {
    return str
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;');
}

function indentContent(content: string, spaces: number): string {
    const indent = ' '.repeat(spaces);
    return content
        .split('\n')
        .map(line => indent + line)
        .join('\n');
}

/**
 * Generate a diff operation from a node modification
 */
export function createReplaceOperation(
    selector: string,
    newValue: string,
    description?: string,
    confidence: DiffOperation['confidence'] = 'high',
    warning?: string
): Omit<DiffOperation, 'id'> {
    return {
        type: 'replace',
        selector,
        newValue,
        description,
        confidence,
        warning,
    };
}

export function createAddOperation(
    selector: string,
    xmlContent: string,
    position: AddPosition = 'append',
    description?: string,
    confidence: DiffOperation['confidence'] = 'high',
    warning?: string
): Omit<DiffOperation, 'id'> {
    return {
        type: 'add',
        selector,
        xmlContent,
        position,
        description,
        confidence,
        warning,
    };
}

export function createRemoveOperation(
    selector: string,
    description?: string,
    confidence: DiffOperation['confidence'] = 'high',
    warning?: string
): Omit<DiffOperation, 'id'> {
    return {
        type: 'remove',
        selector,
        description,
        confidence,
        warning,
    };
}

/**
 * Validate diff operations for common issues
 */
export function validateDiffOperations(operations: DiffOperation[]): string[] {
    const warnings: string[] = [];

    // Check for duplicate selectors
    const selectors = new Map<string, number>();
    for (const op of operations) {
        const count = selectors.get(op.selector) || 0;
        selectors.set(op.selector, count + 1);
    }

    for (const [selector, count] of selectors) {
        if (count > 1) {
            warnings.push(`Duplicate selector used ${count} times: ${selector}`);
        }
    }

    // Check for conflicting operations
    for (let i = 0; i < operations.length; i++) {
        for (let j = i + 1; j < operations.length; j++) {
            const a = operations[i];
            const b = operations[j];

            // Remove then modify same element
            if (a.type === 'remove' && b.selector.startsWith(a.selector)) {
                warnings.push(`Operation ${j + 1} targets a node that will be removed by operation ${i + 1}`);
            }
        }
    }

    return warnings;
}
