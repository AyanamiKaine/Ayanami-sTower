---
import Flashcard from "../components/Flashcard.astro";
import CodeBlock from "../components/CodeBlock.astro";
import NotePreview from "../components/NotePreview.svelte";
import Quiz from "../components/Quiz.astro";
---

<!-- Programming Flashcards -->
<Flashcard
    id="programming-1"
    tags={["programming", "javascript"]}
    source="programming.astro"
    references={[
        "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures",
        "JavaScript: The Definitive Guide, 7th Edition, Chapter 8",
        "You Don't Know JS: Scope & Closures by Kyle Simpson",
    ]}
>
    <Fragment slot="front">
        <h3>What is a closure in JavaScript?</h3>
        <p>Explain with an example.</p>
    </Fragment>
    <Fragment slot="back">
        <p>
            A <a target="_blank" href="/notes/closures-explained">closure</a> is
            a function that has access to variables in its outer (enclosing) <a
                target="_blank"
                href="/notes/lexical-scope">lexical scope</a
            >, even after the outer function has returned.
        </p>
        <CodeBlock
            lang="javascript"
            code={`function outer() {
  let count = 0;
  return function inner() {
    count++;
    return count;
  }
}`}
        />
    </Fragment>
</Flashcard>

<Flashcard
    id="programming-2"
    tags={["programming", "concepts"]}
    source="programming.astro"
>
    <Fragment slot="front">
        <h3>
            What is the difference between <code>var</code>, <code>let</code>,
            and <code>const</code>?
        </h3>
    </Fragment>
    <Fragment slot="back">
        <ul>
            <li>
                <strong>var</strong>: Function-scoped, can be redeclared,
                hoisted
            </li>
            <li>
                <strong>let</strong>: Block-scoped, cannot be redeclared, not
                hoisted
            </li>
            <li>
                <strong>const</strong>: Block-scoped, cannot be redeclared or
                reassigned, not hoisted
            </li>
        </ul>
    </Fragment>
</Flashcard>

<Flashcard
    id="programming-3"
    tags={["programming", "datastructures"]}
    source="programming.astro"
>
    <Fragment slot="front">
        <h3>
            What are the two fundamental datastructures that can be used to
            create any other?
        </h3>
    </Fragment>
    <Fragment slot="back">
        <ul>
            <li>
                <strong>Linked-Lists</strong>: Dynamic size, efficient
                insertions/deletions
            </li>
            <li>
                <strong>Arrays</strong>: Fixed size, efficient random access.
            </li>
        </ul>
    </Fragment>
</Flashcard>

<Flashcard
    id="programming-3"
    tags={["programming", "Dynamic Programming"]}
    source="programming.astro"
>
    <Fragment slot="front">
        <h3>Explain what is dynamic programming for a technique?</h3>
    </Fragment>
    <Fragment slot="back">
        <p>
            You <strong
                ><i>break down a complex problem into simpler subproblems</i
                ></strong
            >, solve each subproblem just once, and often store their solutions
            as they are used in subsequent computations.
        </p>
        <p>
            Another characteristic of dynamic programming is the usage of
            <strong>recursion</strong>.
        </p>
        <p>
            The best example of dynamic programming is calculating Fibonacci
            numbers.
        </p>
        <CodeBlock
            lang="javascript"
            code={`function fibonacci(n, memo = {}) {
  if (n <= 1) return n;
  if (memo[n]) return memo[n];
  memo[n] = fibonacci(n - 1, memo) + fibonacci(n - 2, memo);
  return memo[n];
}`}
        />
    </Fragment>
</Flashcard>

<Quiz
    id="quiz-programming-1"
    question="What are higher-order-functions in programming?"
    options={[
        "Functions that operate on data structures like arrays or objects",
        "Functions that take other functions as arguments or return functions",
        "Variables that hold primitive values like numbers or strings",
        "Classes that inherit from a parent class",
    ]}
    correctIndex={1}
    tags={["programming", "concepts", "functional-programming"]}
    priority={5}
    source="programming.astro"
    references={["https://en.wikipedia.org/wiki/Higher-order_function"]}
/>

<Flashcard
    id="c-void-pointer-rules"
    tags={["c", "pointers", "memory-management"]}
    source="c-programming.astro"
    references={[
        "K&R C Programming Language, Chapter 5",
        "C Standard Library documentation (malloc/qsort)",
    ]}
>
    <Fragment slot="front">
        <h3>
            What is a <code>void*</code> (void pointer) and what are the two strict
            restrictions on its usage?
        </h3>
    </Fragment>
    <Fragment slot="back">
        <p>
            A <strong>void pointer</strong> is a generic pointer that can hold the
            address of <em>any</em> data type, but has no type information itself.
        </p>
        <p><strong>The Two Restrictions:</strong></p>
        <ul>
            <li>
                <strong>No Dereferencing:</strong> You cannot use <code
                    >*ptr</code
                > because the compiler doesn't know the data size (1 byte? 4 bytes?).
            </li>
            <li>
                <strong>No Arithmetic:</strong> You cannot use <code>ptr++</code
                > because the compiler doesn't know how many bytes to jump.
            </li>
        </ul>
        <p>
            You <strong>must</strong> explicitly cast it to a specific type before
            doing either.
        </p>
        <CodeBlock
            lang="c"
            code={`int a = 10;
void* ptr = &a;

// COMPILER ERROR
// printf("%d", *ptr); 

// CORRECT (Cast first)
printf("%d", *(int*)ptr);`}
        />
    </Fragment>
</Flashcard>

<Quiz
    id="quiz-c-void-pointer-limitations"
    question="Which of the following operations will result in a compiler error if 'p' is defined as 'void* p'?"
    options={[
        "Assigning the address of an int to it (p = &my_int;)",
        "Comparing it to NULL (if (p == NULL) ...)",
        "Dereferencing it directly to read a value (int x = *p;)",
        "Casting it to another pointer type (int* i = (int*)p;)",
    ]}
    correctIndex={2}
    tags={["c", "pointers", "safety"]}
    priority={10}
    source="c-programming.astro"
    explanation="You cannot dereference a void pointer (*p) directly because the compiler does not know the size of the data type pointed to (it could be a char, int, float, or struct). You must cast it first."
/>
