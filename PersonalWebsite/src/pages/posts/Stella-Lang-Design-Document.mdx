---
title: "Stella-Lang Design Document"
date: 2025-07-23
author: "Ayanami Kaine"
tags: ["Programming", "Language Design"]
layout: ../../layouts/PostLayout.astro
summary: "Stella-Lang is an experimental ecs language with the wished ability to execute abitrary code in a sound and safe manner."
published: true
---

*This is my personal design document for my toy language stella-lang. It will be updated over time and will include various notes about the language.*

## Idea

The basic idea came from two things. The desire to model domains like we do for games in a `Entity-Component-System` framework and being able to execute arbitrary code.

Most language don't have a safe way to just execute code. Instead, they provide a `eval` function that can execute any code without being able to set permissions or restrict what can run. This usually results in problems down the line because now we need to sanitize the input before. If we missed something we have a problem.

### A list of wishes for sandboxes 

- By default, system-APIs should not work. Instead, we need to give the sandbox permission, also having a virtual file system would be a good idea.
- Each sandbox must be able to be limited how much CPU or memory it can use. We don't want to be able to execute programs that consume too much. 
- Sandboxes should be able to also execute arbitrary code.
- Sandboxes should be able to run in the same process for fast access to shared memory.
- The user should be able to supply symbols it can read and use. We should make a distinction between what can be read and what can be mutated.

### A list of wishes for the ECS framework

- We should be able to define components at runtime.
- We should be able to easily model relationships. Similar to how [Flecs](https://www.flecs.dev/flecs/md_docs_2Relationships.html) does it.
- ECS commands that mutate the world should probably be written in a Command Buffer so we can apply changes to the ECS world in sequential order.
- It must be simple to implement. We can't just sacrifice too much simplicity because of performance. The framework needs to be able to be easily ported to other languages.


## Update 30.07.25

I think I come closer to a solution. What if we instead of creating my own interpreter for an ECS language instead we built a really easy java-like language syntax built our ECS library on that and write a compiler that compiles the library to other languages. I first thought about using [Haxe](https://haxe.org/), but It's not well suited for creating libraries to be transpiled but instead for programs to be transpiled.

Instead of a new syntax we would expose a common API.

## Update 02.08.25

Usually you should write to an interface not a concrete implementation. I was thinking about this and multiple dispatch. By default, queries are written against the interface of a component it does not matter if the entity has 4 others that are not relevant. We could write a runtime system that like a query checks if an entity has the needed components and if not the method does not run.

Using sparsed sets this lookup is as easy as checking an index in an array. So conceptually it should be easy to do. The hard part would be adding this runtime check to the compiler. I.e. the question can we turn this runtime type check into a compile one. And I don't think that would be possible without sacrificing a big part of what makes the system dynamic. 

The other hard part would be creating an interface that is easy to use and not that verbose.

On a side note, I was thinking about arena allocators and object life times. Is quite interesting how we can create ECS worlds with entities of similar lifetime and simply de-allocate the world and all entities and their components at ones. Or just a group of entities by destroying them. Nothing special, but something interesting I thought about.

## The Syntax

The syntax should make it really easy to query entities. Maybe we take a bite out of SQL?

```
entities with (velocity2D or velocity3D) and (position2D or position3D) without (health or mana)
```

Here we would get entities that have `velocity2D` or `velocity3D` and `position2D` or `position3D` components but neither `health` nor a `mana` component. This would introduce the keywords `with`, `or`, `and`, `without`.

This would represent the most basic query expression. But we should allow for more complex ones like:

```
entities with velocity2D where X > 0
```

The desire is to be able to have conditions that filter entities. Here we want entities that have a velocity2D component with a higher x velocity than 0. We would introduce a `where` keyword.

Then we should be able to query entities by identifier.

```
entity with name == "Tom"
```

Often times we will have component that just represent one value like a name component or health component. We should be able to define them in a manner so we don't have to write `name.value` but instead simply as `name`.

Another desired feature would be being able to write systems that update the ecs world.

#### Hierarchical relationships (parent-child):

```
entities with Transform where parent.name == "World"
entities with Transform.children[*].Health > 50
entity with name "Player" children with Weapon
```

#### Graph relationships

```
entities with (Likes, "Pizza") 
entities with (ChildOf, ?parent) where parent.name == "Tom"
entities with (Owns, Weapon) and (Equipped, same)
```
- The `same` keyword could refer back to previously matched entities in the query.

#### Relationship traversal

```
entities connected to "Player" via Friendship
entities reachable from "RootNode" via ChildOf within 3 hops
entities with Health < 20 and (Ally, ?friend) where friend.Mana > 100
```

#### Relationship queries with constraints

```
entities where count(children with Enemy) > 5
entities with (Owns, ?item) where item has Weapon and item.damage > 50
pairs (Loves, Hates) for entity "Romeo"
```

### Formal Notation (EBNF)

```EBNF
(* Stella-Lang EBNF Grammar *)
(* Main query expressions *)

program = { statement } ;

statement = query_statement | system_definition | component_definition ;

(* Query Statements *)
query_statement = entity_query | entities_query ;

entity_query = "entity" entity_selector ;
entities_query = "entities" entity_selector ;

entity_selector = with_clause [ where_clause ] [ relationship_clause ] ;

(* Component and condition clauses *)
with_clause = "with" component_expression ;
without_clause = "without" component_expression ;
where_clause = "where" condition_expression ;

component_expression = component_term { ( "and" | "or" ) component_term } ;
component_term = component_spec | "(" component_expression ")" | without_clause ;

component_spec = component_name [ component_access ] ;
component_name = identifier ;
component_access = "." field_name | "[" index_expression "]" | "." field_name "[" index_expression "]" ;

(* Relationship clauses *)
relationship_clause = children_clause | connected_clause | reachable_clause | pairs_clause ;

children_clause = "children" [ entity_selector ] ;
connected_clause = "connected" "to" entity_reference "via" relationship_name ;
reachable_clause = "reachable" "from" entity_reference "via" relationship_name [ "within" number "hops" ] ;
pairs_clause = "pairs" "(" relationship_name "," relationship_name ")" "for" entity_reference ;

(* Condition expressions *)
condition_expression = logical_or_expression ;

logical_or_expression = logical_and_expression { "or" logical_and_expression } ;
logical_and_expression = equality_expression { "and" equality_expression } ;

equality_expression = relational_expression [ ( "==" | "!=" ) relational_expression ] ;
relational_expression = additive_expression [ ( "<" | ">" | "<=" | ">=" ) additive_expression ] ;

additive_expression = multiplicative_expression { ( "+" | "-" ) multiplicative_expression } ;
multiplicative_expression = unary_expression { ( "*" | "/" | "%" ) unary_expression } ;

unary_expression = [ ( "!" | "-" | "+" ) ] primary_expression ;

primary_expression = 
    | literal
    | identifier [ component_access ]
    | entity_reference
    | relationship_expression
    | function_call
    | "(" condition_expression ")";

(* Relationship expressions *)
relationship_expression = 
    | "(" relationship_name "," entity_reference ")"
    | "(" relationship_name "," variable ")"
    | "(" relationship_name "," "same" ")" ;

relationship_name = identifier ;

field_expression = identifier [ component_access ] ;

function_call = identifier "(" [ argument_list ] ")" ;
argument_list = condition_expression { "," condition_expression } ;

(* Entity references and variables *)
entity_reference = 
    | string_literal
    | identifier
    | variable ;

variable = "?" identifier ;

(* Index expressions for array access *)
index_expression = 
    | number
    | "*"
    | condition_expression ;

(* System definitions *)
system_definition = "system" identifier "{" { system_statement } "}" ;

system_statement = 
    | query_statement
    | assignment_statement
    | if_statement
    | for_statement
    | command_statement ;

assignment_statement = identifier [ component_access ] "=" condition_expression ";" ;

if_statement = "if" "(" condition_expression ")" "{" { system_statement } "}" [ "else" "{" { system_statement } "}" ] ;

for_statement = "for" identifier "in" entity_selector "{" { system_statement } "}" ;

command_statement = command_name "(" [ argument_list ] ")" ";" ;
command_name = "spawn" | "despawn" | "add_component" | "remove_component" | identifier ;

(* Component definitions *)
component_definition = "component" identifier "{" { field_definition } "}" ;
field_definition = field_name ":" type_name [ "=" literal ] ";" ;

(* Basic tokens *)
identifier = letter { letter | digit | "_" } ;
field_name = identifier ;
type_name = "i32" | "f64" | "string" | "bool" | identifier ;

literal = number | string_literal | boolean_literal ;
number = integer | float ;
integer = digit { digit } ;
float = digit { digit } "." digit { digit } ;
string_literal = '"' { character } '"' ;
boolean_literal = "true" | "false" ;

letter = "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" 
       | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z"
       | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M"
       | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" ;

digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;

character = letter | digit | " " | "!" | "#" | "$" | "%" | "&" | "'" | "(" | ")" | "*" 
          | "+" | "," | "-" | "." | "/" | ":" | ";" | "<" | "=" | ">" | "?" | "@" | "[" 
          | "]" | "^" | "_" | "`" | "{" | "|" | "}" | "~" ;

(* Comments and whitespace *)
comment = "//" { character } newline | "/*" { character } "*/" ;
whitespace = " " | "\t" | "\n" | "\r" ;
newline = "\n" | "\r\n" ;
```


## The Sandbox 

Should sandboxes run on another thread? Probably but this opens the gate for race conditions when the ECS world gets exposed. We could just implement looks for components maybe we are doing that. So no two threads at the same time can mutate ECS data.

How would the runtime look like? We could use Wasm either [wasmtime](https://wasmtime.dev/) or [wasmer](https://wasmer.io/products/runtime). I personally feel that wasmtime could be a good choice. Because its nonprofit while wasmer is for-profit. It does not mean you have to pay for wasmer to use it. Both have different sets of features we have to keep in mind. For example, it seems that wasmer is [able to run clang](https://wasmer.io/posts/clang-in-browser) completely in his runtime. (On a side note: While actually trying to run clang with wasmer and trying out the donut example and simply didn't work...)