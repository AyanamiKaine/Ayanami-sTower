<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Galaxy Map Editor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510;
            font-family: 'Inter', sans-serif;
            color: #fff;
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        canvas.space-panning {
            cursor: grabbing;
        }

        canvas.adding {
            cursor: crosshair;
        }

        canvas.connecting {
            cursor: pointer;
        }

        canvas.deleting {
            cursor: not-allowed;
        }

        canvas.dragging-star,
        canvas.dragging-planet {
            cursor: move;
        }

        .ui-panel,
        .system-ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(5px);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 160px;
        }

        .system-ui-panel {
            width: 200px;
        }

        .system-ui-panel h2 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: #a0c4ff;
            text-align: center;
        }

        .celestial-body-list {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .celestial-body-item {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .celestial-body-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .celestial-body-item.selected {
            background-color: rgba(79, 70, 229, 0.3);
            border-left: 3px solid #6366f1;
            font-weight: bold;
        }

        .celestial-body-item.moon {
            padding-left: 20px;
            font-size: 0.9em;
            position: relative;
        }

        .celestial-body-item.moon::before {
            content: 'L';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-family: monospace;
            color: #9ca3af;
        }

        #galaxyNameInput {
            background-color: transparent;
            border: none;
            border-bottom: 1px solid #4b5563;
            color: #a0c4ff;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            margin-bottom: 5px;
            outline: none;
        }

        #galaxyNameInput:focus {
            border-bottom-color: #6366f1;
        }

        .ui-panel button,
        .system-ui-panel button {
            background-color: #374151;
            color: #e5e7eb;
            border: 1px solid #4b5563;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .ui-panel button:hover,
        .system-ui-panel button:hover {
            background-color: #4b5563;
        }

        .ui-panel button:disabled,
        .system-ui-panel button:disabled {
            background-color: #1f2937;
            color: #4b5563;
            cursor: not-allowed;
        }

        .ui-panel button.active {
            background-color: #4f46e5;
            border-color: #6366f1;
            color: #fff;
            font-weight: bold;
        }

        .ui-panel button.active-delete {
            background-color: #dc2626;
            border-color: #f87171;
            color: #fff;
            font-weight: bold;
        }

        .history-buttons,
        .io-buttons {
            margin-top: 10px;
            border-top: 1px solid #4b5563;
            padding-top: 10px;
            display: flex;
            gap: 10px;
        }

        .history-buttons button,
        .io-buttons button {
            flex-grow: 1;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 220px;
            display: none;
            /* Hidden by default */
        }

        .info-panel h2 {
            margin: 0 0 10px 0;
            color: #a0c4ff;
            font-size: 16px;
        }

        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
            color: #d1d5db;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-panel span,
        .info-panel input {
            font-weight: bold;
            color: #fff;
            background-color: transparent;
            border: none;
            text-align: right;
            outline: none;
        }

        .info-panel input {
            background-color: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid #4b5563;
            padding: 2px 4px;
            width: 120px;
        }

        .info-panel input:focus {
            border-bottom-color: #6366f1;
        }

        .coords-display,
        .hint-display {
            position: absolute;
            bottom: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #9ca3af;
        }

        .coords-display {
            right: 10px;
        }

        .hint-display {
            left: 10px;
        }

        .hint-display kbd {
            background-color: #374151;
            border: 1px solid #4b5563;
            border-radius: 3px;
            padding: 1px 4px;
            font-family: inherit;
            font-size: 11px;
        }

        .hint-display-move {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #9ca3af;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #1f2937;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #4b5563;
            width: 300px;
            text-align: center;
        }

        .modal-content label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .modal-content input {
            width: calc(100% - 20px);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: #fff;
            font-size: 14px;
        }

        .modal-content .modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
        }

        .regions-panel {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(5px);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 200px;
            z-index: 5;
        }

        .regions-panel h2 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: #a0c4ff;
            text-align: center;
        }

        #regionList {
            max-height: 200px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .region-item {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: background-color 0.2s, border-color 0.2s;
            display: flex;
            align-items: center;
            gap: 8px;
            justify-content: space-between;
        }

        .region-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .region-item-color {
            width: 12px;
            height: 12px;
            border-radius: 3px;
            flex-shrink: 0;
        }

        .region-color-input {
            -webkit-appearance: none;
            -moz-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            background-color: transparent;
            border: none;
            cursor: pointer;
            padding: 0;
            border-radius: 4px;
        }

        .region-color-input::-webkit-color-swatch {
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .region-color-input::-moz-color-swatch {
            border-radius: 4px;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .region-name-input {
            background-color: rgba(0, 0, 0, 0.3);
            border: 1px solid #6366f1;
            color: #fff;
            font-family: inherit;
            font-size: inherit;
            padding: 2px 4px;
            border-radius: 3px;
            outline: none;
            width: 100%;
        }

        #regionAssignment,
        #regionAssignment select {
            width: 100%;
            color: #fff;
            background-color: transparent;
        }

        #regionAssignment select {
            background-color: #374151;
            border: 1px solid #4b5563;
            padding: 4px;
            border-radius: 4px;
            margin-top: 4px;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <div id="galaxyUI" class="ui-panel">
        <input type="text" id="galaxyNameInput" value="My Galaxy">
        <button id="addStarBtn">Add System</button>
        <button id="connectStarBtn">Connect</button>
        <button id="deleteBtn">Delete</button>
        <div class="history-buttons">
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
        </div>
        <div class="io-buttons">
            <button id="importBtn">Import</button>
            <button id="exportBtn">Export</button>
        </div>
    </div>

    <div id="systemUI" class="system-ui-panel" style="display: none;">
        <h2 id="systemNameTitle">System Name</h2>
        <div id="celestialBodyList" class="celestial-body-list"></div>
        <button id="addPlanetBtn">Add Planet</button>
        <button id="addMoonBtn" style="display:none;">Add Moon</button>
        <button id="addAsteroidBtn">Add Asteroid</button>
        <button id="addAsteroidFieldBtn">Add Ast. Field</button>
        <button id="deleteBodyBtn">Delete</button>
        <button id="backToGalaxyBtn">Back to Galaxy</button>
    </div>

    <div id="infoPanel" class="info-panel">
        <h2 id="infoTitle">Selection Info</h2>
        <div id="singleSelectInfo">
            <p>Name: <input type="text" id="infoNameInput"></p>
            <p>Coords: <span id="infoCoords"></span></p>
            <p>Connections: <span id="infoConnections"></span></p>
        </div>
        <div id="planetSelectInfo" style="display: none;">
            <p>Name: <input type="text" id="planetNameInput"></p>
            <p>Orbit: <input type="number" id="planetOrbitInput" step="10"></p>
            <p>Size: <input type="number" id="planetSizeInput" step="0.5"></p>
        </div>
        <div id="moonSelectInfo" style="display: none;">
            <p>Name: <input type="text" id="moonNameInput"></p>
            <p>Orbit: <input type="number" id="moonOrbitInput" step="1"></p>
            <p>Size: <input type="number" id="moonSizeInput" step="0.1"></p>
        </div>
        <div id="asteroidFieldSelectInfo" style="display: none;">
            <p>Name: <input type="text" id="asteroidFieldNameInput"></p>
            <p>Radius: <input type="number" id="asteroidFieldRadiusInput" step="10"></p>
            <p>Density: <input type="number" id="asteroidFieldCountInput" step="10"></p>
        </div>
        <div id="multiSelectInfo" style="display: none;">
            <p><span id="multiSelectCount">0</span> systems selected</p>
        </div>

        <div id="regionAssignment" style="display: none;">
            <p>Region:
                <select id="regionAssignSelect">
                    <option value="-1">-- None --</option>
                </select>
            </p>
        </div>

    </div>

    <div id="regionsPanel" class="regions-panel">
        <h2>Regions</h2>
        <div id="regionList"></div>
        <button id="createRegionBtn">Create Region</button>
    </div>

    <div id="coordsDisplay" class="coords-display">X: 0, Y: 0</div>
    <div class="hint-display">Hold <kbd>Space</kbd> to Pan</div>
    <div class="hint-display-move">Hold <kbd>Ctrl</kbd> + Drag to Move</div>

    <div id="nameModal" class="modal-backdrop">
        <div class="modal-content">
            <label for="nameInput">Enter System Name:</label>
            <input type="text" id="nameInput" placeholder="e.g., Sol">
            <div class="modal-buttons">
                <button id="confirmNameBtn">Create</button>
                <button id="cancelNameBtn">Cancel</button>
            </div>
        </div>
    </div>

    <div id="regionNameModal" class="modal-backdrop">
        <div class="modal-content">
            <label for="regionNameInput">Enter Region Name:</label>
            <input type="text" id="regionNameInput" placeholder="e.g., The Veil">
            <div class="modal-buttons">
                <button id="confirmRegionNameBtn">Create</button>
                <button id="cancelRegionNameBtn">Cancel</button>
            </div>
        </div>
    </div>

    <input type="file" id="xmlImporter" accept=".xml" style="display: none;">

    <canvas id="galaxyCanvas"></canvas>

    <script>
        const canvas = document.getElementById('galaxyCanvas');
        const ctx = canvas.getContext('2d');

        const STAR_LAYERS = [
            { count: 1000, minSize: 0.5, maxSize: 1.2, parallax: 0.1, color: 'rgba(255, 255, 255, 0.5)' },
            { count: 500, minSize: 0.8, maxSize: 1.8, parallax: 0.25, color: 'rgba(255, 255, 255, 0.7)' },
            { count: 150, minSize: 1.2, maxSize: 2.5, parallax: 0.5, color: 'rgba(255, 255, 255, 0.9)' }
        ];
        let starfield = [];
        const STARFIELD_BOUNDS = 5000;

        const NEBULA_CONFIG = {
            count: 15,
            colors: [
                { r: 168, g: 50, b: 132 }, { r: 50, g: 86, b: 168 }, { r: 90, g: 34, b: 139 },
            ],
            parallax: 0.05
        };
        let nebulae = [];

        const MIN_ZOOM = 0.05;
        const MAX_ZOOM = 15.0;
        const ZOOM_LERP_FACTOR = 0.2;
        const TEXT_FADE_START_ZOOM = 0.7;
        const TEXT_FADE_END_ZOOM = 0.4;
        let stars = [];
        let connections = [];
        let regions = [];
        let nextRegionId = 0;

        const REGION_COLORS = [
            'rgba(239, 68, 68, 0.2)', 'rgba(59, 130, 246, 0.2)', 'rgba(34, 197, 94, 0.2)',
            'rgba(234, 179, 8, 0.2)', 'rgba(168, 85, 247, 0.2)', 'rgba(249, 115, 22, 0.2)'
        ];

        const MAX_HULL_EDGE_LENGTH = 200;
        const JIGGLE_FACTOR = 0.1;
        const STAR_BUFFER_RADIUS = 40;
        const STAR_BUFFER_POINTS = 6;
        const STAR_FADE_START_ZOOM = 0.5;
        const STAR_FADE_END_ZOOM = 0.2;
        const REGION_TEXT_FADE_START_ZOOM = 0.2;
        const REGION_TEXT_FADE_END_ZOOM = 0.15;
        const MAX_REGION_FONT_SIZE = 70;

        let editorState = {
            mode: 'pan', view: 'galaxy', activeSystemId: null, selectedCelestialBodyId: null,
            draggedBody: null, drawingAstField: null, isSpacebarPan: false,
            selection: [], groupDrag: null, selectionBox: null,
            firstStarForConnection: null, hoveredStar: null, hoveredBodyId: null,
            hoveredConnection: null, lastMousePos: { x: 0, y: 0 },
        };
        let camera = { x: 0, y: 0, zoom: 1.0, targetZoom: 1.0, isDragging: false, lastX: 0, lastY: 0, };
        let nextStarId = 0;
        let nextBodyId = 0;
        let pendingStar = null;
        let history = [];
        let historyIndex = -1;

        const regionNameModal = document.getElementById('regionNameModal');
        const regionNameInput = document.getElementById('regionNameInput');
        const confirmRegionNameBtn = document.getElementById('confirmRegionNameBtn');
        const cancelRegionNameBtn = document.getElementById('cancelRegionNameBtn');
        const galaxyUI = document.getElementById('galaxyUI');
        const systemUI = document.getElementById('systemUI');
        const backToGalaxyBtn = document.getElementById('backToGalaxyBtn');
        const addPlanetBtn = document.getElementById('addPlanetBtn');
        const addMoonBtn = document.getElementById('addMoonBtn');
        const addAsteroidBtn = document.getElementById('addAsteroidBtn');
        const addAsteroidFieldBtn = document.getElementById('addAsteroidFieldBtn');
        const addStarBtn = document.getElementById('addStarBtn');
        const connectStarBtn = document.getElementById('connectStarBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const deleteBodyBtn = document.getElementById('deleteBodyBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        const xmlImporter = document.getElementById('xmlImporter');
        const galaxyNameInput = document.getElementById('galaxyNameInput');
        const nameModal = document.getElementById('nameModal');
        const nameInput = document.getElementById('nameInput');
        const confirmNameBtn = document.getElementById('confirmNameBtn');
        const cancelNameBtn = document.getElementById('cancelNameBtn');
        const infoPanel = document.getElementById('infoPanel');
        const infoNameInput = document.getElementById('infoNameInput');
        const coordsDisplay = document.getElementById('coordsDisplay');
        const singleSelectInfo = document.getElementById('singleSelectInfo');
        const planetSelectInfo = document.getElementById('planetSelectInfo');
        const moonSelectInfo = document.getElementById('moonSelectInfo');
        const asteroidFieldSelectInfo = document.getElementById('asteroidFieldSelectInfo');
        const multiSelectInfo = document.getElementById('multiSelectInfo');
        const regionsPanel = document.getElementById('regionsPanel');
        const regionList = document.getElementById('regionList');
        const createRegionBtn = document.getElementById('createRegionBtn');
        const regionAssignment = document.getElementById('regionAssignment');
        const regionAssignSelect = document.getElementById('regionAssignSelect');

        function setupCanvasDPI() {
            const dpi = window.devicePixelRatio || 1;
            const style = getComputedStyle(canvas);
            const cssWidth = +style.width.slice(0, -2);
            const cssHeight = +style.height.slice(0, -2);
            canvas.setAttribute('width', cssWidth * dpi);
            canvas.setAttribute('height', cssHeight * dpi);
            ctx.scale(dpi, dpi);
        }

        function screenToWorld(x, y) {
            return {
                x: (x - canvas.clientWidth / 2) / camera.zoom + camera.x,
                y: (y - canvas.clientHeight / 2) / camera.zoom + camera.y
            };
        }

        function createStarfield() {
            STAR_LAYERS.forEach(layer => {
                const stars = [];
                for (let i = 0; i < layer.count; i++) {
                    const sizeRange = layer.maxSize - layer.minSize;
                    stars.push({
                        x: (Math.random() - 0.5) * STARFIELD_BOUNDS,
                        y: (Math.random() - 0.5) * STARFIELD_BOUNDS,
                        baseRadius: Math.random() * sizeRange + layer.minSize,
                        shimmer: Math.random()
                    });
                }
                starfield.push({ config: layer, stars: stars });
            });
        }

        function createNebulae() {
            for (let i = 0; i < NEBULA_CONFIG.count; i++) {
                const color = NEBULA_CONFIG.colors[Math.floor(Math.random() * NEBULA_CONFIG.colors.length)];
                nebulae.push({
                    x: (Math.random() - 0.5) * STARFIELD_BOUNDS,
                    y: (Math.random() - 0.5) * STARFIELD_BOUNDS,
                    radius: (Math.random() * 0.5 + 0.5) * 800,
                    color: color
                });
            }
        }

        function drawStarfield() {
            const halfWidth = canvas.clientWidth / 2;
            const halfHeight = canvas.clientHeight / 2;
            starfield.forEach(layer => {
                ctx.fillStyle = layer.config.color;
                ctx.beginPath();
                layer.stars.forEach(star => {
                    const viewX = camera.x * layer.config.parallax;
                    const viewY = camera.y * layer.config.parallax;
                    let sx = ((star.x - viewX) % STARFIELD_BOUNDS + STARFIELD_BOUNDS) % STARFIELD_BOUNDS - (STARFIELD_BOUNDS / 2);
                    let sy = ((star.y - viewY) % STARFIELD_BOUNDS + STARFIELD_BOUNDS) % STARFIELD_BOUNDS - (STARFIELD_BOUNDS / 2);
                    sx += halfWidth;
                    sy += halfHeight;
                    const shimmerFactor = 0.5 + Math.sin((Date.now() / 1500) + star.shimmer * Math.PI * 2) * 0.5;
                    const radius = star.baseRadius * shimmerFactor;
                    ctx.rect(sx, sy, radius, radius);
                });
                ctx.fill();
            });
        }

        function drawNebulae() {
            const halfWidth = canvas.clientWidth / 2;
            const halfHeight = canvas.clientHeight / 2;
            nebulae.forEach(nebula => {
                const viewX = camera.x * NEBULA_CONFIG.parallax;
                const viewY = camera.y * NEBULA_CONFIG.parallax;
                let sx = ((nebula.x - viewX) % STARFIELD_BOUNDS + STARFIELD_BOUNDS) % STARFIELD_BOUNDS - (STARFIELD_BOUNDS / 2);
                let sy = ((nebula.y - viewY) % STARFIELD_BOUNDS + STARFIELD_BOUNDS) % STARFIELD_BOUNDS - (STARFIELD_BOUNDS / 2);
                sx += halfWidth;
                sy += halfHeight;
                const gradient = ctx.createRadialGradient(sx, sy, 0, sx, sy, nebula.radius);
                const { r, g, b } = nebula.color;
                gradient.addColorStop(0, `rgba(${r}, ${g}, ${b}, 0.15)`);
                gradient.addColorStop(1, `rgba(${r}, ${g}, ${b}, 0)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(sx - nebula.radius, sy - nebula.radius, nebula.radius * 2, nebula.radius * 2);
            });
        }

        function getStarAt(worldX, worldY) {
            const clickRadius = 15 / camera.zoom;
            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                if (Math.sqrt((worldX - star.x) ** 2 + (worldY - star.y) ** 2) < clickRadius) {
                    return star;
                }
            }
            return null;
        }

        function getConnectionAt(worldX, worldY) {
            const clickThreshold = 5 / camera.zoom;
            for (const conn of connections) {
                const p1 = stars.find(s => s.id === conn.p1_id);
                const p2 = stars.find(s => s.id === conn.p2_id);
                if (!p1 || !p2) continue;

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const lenSq = dx * dx + dy * dy;

                if (lenSq === 0) continue;

                let t = ((worldX - p1.x) * dx + (worldY - p1.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));

                const closestX = p1.x + t * dx;
                const closestY = p1.y + t * dy;

                if ((worldX - closestX) ** 2 + (worldY - closestY) ** 2 < clickThreshold ** 2) {
                    return conn;
                }
            }
            return null;
        }

        function getBodyAt(worldX, worldY, system) {
            if (!system) return null;

            // Check planets and moons
            for (const body of system.celestialBodies) {
                if (body.type !== 'planet') continue;

                let planetX = Math.cos(body.orbitAngle) * body.orbitRadius;
                let planetY = Math.sin(body.orbitAngle) * body.orbitRadius;

                // Check moons first (as they are "on top" of planets)
                if (body.moons) {
                    for (const moon of body.moons) {
                        const moonX = planetX + Math.cos(moon.orbitAngle) * moon.orbitRadius;
                        const moonY = planetY + Math.sin(moon.orbitAngle) * moon.orbitRadius;
                        const moonClickRadius = moon.size + (5 / camera.zoom);
                        if (Math.sqrt((worldX - moonX) ** 2 + (worldY - moonY) ** 2) < moonClickRadius) {
                            return moon;
                        }
                    }
                }

                // Check planet
                const clickRadius = body.size + (5 / camera.zoom);
                if (Math.sqrt((worldX - planetX) ** 2 + (worldY - planetY) ** 2) < clickRadius) {
                    return body;
                }
            }

            // Check non-orbiting bodies (asteroids, system star)
            for (const body of system.celestialBodies) {
                if (body.type === 'asteroid' || body.type === 'star') {
                    let bodyX = body.type === 'star' ? 0 : body.x;
                    let bodyY = body.type === 'star' ? 0 : body.y;
                    const clickRadius = (body.size || 2) + (5 / camera.zoom);
                    if (Math.sqrt((worldX - bodyX) ** 2 + (worldY - bodyY) ** 2) < clickRadius) {
                        return body;
                    }
                }
            }

            // Check asteroid fields
            for (const body of system.celestialBodies) {
                if (body.type === 'asteroid_field') {
                    if ((worldX - body.x) ** 2 + (worldY - body.y) ** 2 < body.radius ** 2) {
                        return body;
                    }
                }
            }
            return null;
        }

        function setMode(newMode) {
            if (editorState.mode === 'add_asteroid_field' && editorState.drawingAstField) {
                editorState.drawingAstField = null;
            }
            editorState.mode = (editorState.mode === newMode) ? 'pan' : newMode;
            editorState.firstStarForConnection = null;
            addStarBtn.classList.toggle('active', editorState.mode === 'add');
            connectStarBtn.classList.toggle('active', editorState.mode === 'connect');
            deleteBtn.classList.toggle('active-delete', editorState.mode === 'delete');
            deleteBodyBtn.classList.toggle('active-delete', editorState.mode === 'delete');
            addAsteroidBtn.classList.toggle('active', editorState.mode === 'add_asteroid');
            addAsteroidFieldBtn.classList.toggle('active', editorState.mode === 'add_asteroid_field');
            updateCursor();
        }

        function updateCursor() {
            if (editorState.isSpacebarPan) {
                canvas.style.cursor = camera.isDragging ? 'grabbing' : 'grab';
                return;
            }
            let cursor = 'grab';
            if (editorState.groupDrag || editorState.draggedBody) {
                cursor = 'move';
            } else if (editorState.mode === 'add' || editorState.mode === 'add_asteroid' || editorState.mode === 'add_asteroid_field') {
                cursor = 'crosshair';
            } else if (editorState.mode === 'connect' || editorState.hoveredBodyId !== null) {
                cursor = 'pointer';
            } else if (editorState.mode === 'delete') {
                cursor = 'not-allowed';
            }
            canvas.style.cursor = cursor;
        }

        function updateInfoPanel() {
            const allPanels = [singleSelectInfo, multiSelectInfo, planetSelectInfo, moonSelectInfo, asteroidFieldSelectInfo];
            allPanels.forEach(p => p.style.display = 'none');
            regionAssignment.style.display = 'none';
            infoPanel.style.display = 'none';

            if (editorState.view === 'galaxy') {
                if (editorState.selection.length > 0) {
                    regionAssignment.style.display = 'block';
                    populateRegionAssignSelect();
                }
                if (editorState.selection.length === 1) {
                    const star = stars.find(s => s.id === editorState.selection[0]);
                    if (star) {
                        document.getElementById('infoTitle').textContent = "System Info";
                        infoNameInput.value = star.name;
                        document.getElementById('infoCoords').textContent = `X: ${star.x.toFixed(1)}, Y: ${star.y.toFixed(1)}`;
                        const numConnections = connections.filter(c => c.p1_id === star.id || c.p2_id === star.id).length;
                        document.getElementById('infoConnections').textContent = numConnections;
                        singleSelectInfo.style.display = 'block';
                        infoPanel.style.display = 'block';
                    }
                } else if (editorState.selection.length > 1) {
                    document.getElementById('infoTitle').textContent = "Multiple Selected";
                    document.getElementById('multiSelectCount').textContent = editorState.selection.length;
                    multiSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                }
            } else if (editorState.view === 'system') {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);

                if (body?.type === 'planet') {
                    document.getElementById('infoTitle').textContent = "Planet Info";
                    document.getElementById('planetNameInput').value = body.name;
                    document.getElementById('planetOrbitInput').value = body.orbitRadius.toFixed(1);
                    document.getElementById('planetSizeInput').value = body.size;
                    planetSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                } else if (body?.type === 'moon') {
                    document.getElementById('infoTitle').textContent = "Moon Info";
                    document.getElementById('moonNameInput').value = body.name;
                    document.getElementById('moonOrbitInput').value = body.orbitRadius.toFixed(1);
                    document.getElementById('moonSizeInput').value = body.size;
                    moonSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                } else if (body?.type === 'asteroid_field') {
                    document.getElementById('infoTitle').textContent = "Asteroid Field";
                    document.getElementById('asteroidFieldNameInput').value = body.name;
                    document.getElementById('asteroidFieldRadiusInput').value = body.radius.toFixed(1);
                    document.getElementById('asteroidFieldCountInput').value = body.count;
                    asteroidFieldSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                }
            }
        }

        function render() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#000510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawNebulae();
            drawStarfield();
            ctx.restore();

            ctx.save();
            ctx.translate(canvas.clientWidth / 2, canvas.clientHeight / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            if (editorState.view === 'galaxy') {
                drawGalaxyView();
            } else {
                drawSystemView();
            }

            ctx.restore();
        }

        function getConvexHull(points) {
            if (points.length <= 2) return points;
            points.sort((a, b) => a.x !== b.x ? a.x - b.x : a.y - b.y);

            const cross = (o, a, b) => (a.x - o.x) * (b.y - o.y) - (a.y - o.y) * (b.x - o.x);

            const lower = [];
            for (const p of points) {
                while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {
                    lower.pop();
                }
                lower.push(p);
            }

            const upper = [];
            for (let i = points.length - 1; i >= 0; i--) {
                const p = points[i];
                while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {
                    upper.pop();
                }
                upper.push(p);
            }

            return lower.slice(0, lower.length - 1).concat(upper.slice(0, upper.length - 1));
        }

        function createBlobbyHull(points, systemStars) {
            if (points.length < 2) return points;

            const newPoints = [];
            let seed = systemStars.reduce((a, s) => a + s.id, 0);
            const random = () => { let x = Math.sin(seed++) * 10000; return x - Math.floor(x); };

            for (let i = 0; i < points.length; i++) {
                const p1 = points[i];
                const p2 = points[(i + 1) % points.length];
                newPoints.push(p1);

                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const dist = Math.hypot(dx, dy);
                const subdivisions = Math.floor(dist / MAX_HULL_EDGE_LENGTH);

                if (subdivisions > 0) {
                    const normX = -dy / dist;
                    const normY = dx / dist;
                    for (let j = 1; j <= subdivisions; j++) {
                        const t = j / (subdivisions + 1);
                        const newX = p1.x + dx * t;
                        const newY = p1.y + dy * t;
                        const jiggle = (random() - 0.5) * MAX_HULL_EDGE_LENGTH * JIGGLE_FACTOR;
                        newPoints.push({ x: newX + normX * jiggle, y: newY + normY * jiggle });
                    }
                }
            }
            return newPoints;
        }

        function drawRegions(regionTextToDraw) {
            regions.forEach(region => {
                const regionStars = region.starIds.map(id => stars.find(s => s.id === id)).filter(Boolean);
                if (regionStars.length === 0) return;

                let allBufferedPoints = [];
                if (regionStars.length === 1) {
                    const star = regionStars[0];
                    for (let i = 0; i < STAR_BUFFER_POINTS * 2; i++) {
                        const angle = (i / (STAR_BUFFER_POINTS * 2)) * 2 * Math.PI;
                        allBufferedPoints.push({ x: star.x + STAR_BUFFER_RADIUS * Math.cos(angle), y: star.y + STAR_BUFFER_RADIUS * Math.sin(angle) });
                    }
                } else {
                    regionStars.forEach(star => {
                        for (let i = 0; i < STAR_BUFFER_POINTS; i++) {
                            const angle = (i / STAR_BUFFER_POINTS) * 2 * Math.PI;
                            allBufferedPoints.push({ x: star.x + STAR_BUFFER_RADIUS * Math.cos(angle), y: star.y + STAR_BUFFER_RADIUS * Math.sin(angle) });
                        }
                    });
                }

                const bufferedHull = getConvexHull(allBufferedPoints);
                if (bufferedHull.length < 3) return;

                const blobbyHull = createBlobbyHull(bufferedHull, regionStars);
                ctx.beginPath();
                ctx.fillStyle = region.color;
                ctx.strokeStyle = region.color.replace('0.2', '0.6');
                ctx.lineWidth = 3 / camera.zoom;

                const midpoints = blobbyHull.map((p, i) => { const nextP = blobbyHull[(i + 1) % blobbyHull.length]; return { x: (p.x + nextP.x) / 2, y: (p.y + nextP.y) / 2 }; });
                ctx.moveTo(midpoints[0].x, midpoints[0].y);
                for (let i = 0; i < midpoints.length; i++) {
                    const nextMidpoint = midpoints[(i + 1) % midpoints.length];
                    const controlPoint = blobbyHull[(i + 1) % midpoints.length];
                    ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, nextMidpoint.x, nextMidpoint.y);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();

                const nameCentroid = regionStars.reduce((acc, p) => ({ x: acc.x + p.x, y: acc.y + p.y }), { x: 0, y: 0 });
                nameCentroid.x /= regionStars.length;
                nameCentroid.y /= regionStars.length;
                regionTextToDraw.push({ text: region.name, x: nameCentroid.x, y: nameCentroid.y });
            });
        }

        function drawGalaxyView() {
            const regionTextToDraw = [];
            drawGrid();
            drawRegions(regionTextToDraw);

            ctx.lineWidth = 1.5 / camera.zoom;
            connections.forEach(conn => {
                const p1 = stars.find(s => s.id === conn.p1_id);
                const p2 = stars.find(s => s.id === conn.p2_id);
                if (!p1 || !p2) return;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = (editorState.mode === 'delete' && editorState.hoveredConnection === conn) ? '#ef4444' : 'rgba(100, 150, 255, 0.4)';
                ctx.stroke();
            });

            ctx.font = `${12 / camera.zoom}px Inter`;
            ctx.textAlign = 'center';
            let textAlpha = 1.0;
            if (camera.zoom < TEXT_FADE_START_ZOOM) {
                textAlpha = Math.max(0, Math.min(1, (camera.zoom - TEXT_FADE_END_ZOOM) / (TEXT_FADE_START_ZOOM - TEXT_FADE_END_ZOOM)));
            }

            let starFadeRatio = 0;
            if (camera.zoom < STAR_FADE_START_ZOOM) {
                starFadeRatio = Math.max(0, Math.min(1, (STAR_FADE_START_ZOOM - camera.zoom) / (STAR_FADE_START_ZOOM - STAR_FADE_END_ZOOM)));
            }

            const baseStarSize = 5, minStarSize = 2, starSize = baseStarSize - (baseStarSize - minStarSize) * starFadeRatio;
            const baseStarAlpha = 1.0, minStarAlpha = 0.3, starAlpha = baseStarAlpha - (baseStarAlpha - minStarAlpha) * starFadeRatio;
            const baseShadowBlur = 10, shadowBlur = baseShadowBlur - baseShadowBlur * starFadeRatio;

            stars.forEach(star => {
                if (editorState.selection.includes(star.id)) {
                    ctx.beginPath();
                    ctx.arc(star.x, star.y, (10 / camera.zoom), 0, 2 * Math.PI);
                    ctx.strokeStyle = '#fde047';
                    ctx.lineWidth = 3 / camera.zoom;
                    ctx.stroke();
                }

                ctx.beginPath();
                const isHovered = editorState.hoveredStar === star;
                const isSelectedForConnection = editorState.firstStarForConnection === star;

                if (isHovered || isSelectedForConnection || (editorState.mode === 'delete' && isHovered)) {
                    ctx.arc(star.x, star.y, baseStarSize / camera.zoom, 0, 2 * Math.PI);
                    if (editorState.mode === 'delete' && isHovered) {
                        ctx.fillStyle = '#ef4444';
                        ctx.shadowColor = '#ef4444';
                        ctx.shadowBlur = 20 / camera.zoom;
                    } else {
                        ctx.fillStyle = '#fde047';
                        ctx.shadowColor = '#fde047';
                        ctx.shadowBlur = 20 / camera.zoom;
                    }
                } else {
                    ctx.arc(star.x, star.y, starSize / camera.zoom, 0, 2 * Math.PI);
                    ctx.fillStyle = `rgba(229, 231, 235, ${starAlpha})`;
                    ctx.shadowColor = `rgba(160, 200, 255, ${starAlpha * 0.8})`;
                    ctx.shadowBlur = shadowBlur / camera.zoom;
                }

                ctx.fill();
                ctx.shadowBlur = 0;

                if (textAlpha > 0) {
                    ctx.fillStyle = `rgba(209, 213, 219, ${textAlpha})`;
                    ctx.fillText(star.name, star.x, star.y - 15 / camera.zoom);
                }
            });

            if (editorState.selectionBox) {
                ctx.fillStyle = "rgba(79, 170, 255, 0.2)";
                ctx.strokeStyle = "rgba(129, 199, 255, 0.8)";
                ctx.lineWidth = 1 / camera.zoom;
                const { x1, y1, x2, y2 } = editorState.selectionBox;
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            }

            let regionTextAlpha = 1.0;
            if (camera.zoom < REGION_TEXT_FADE_START_ZOOM) {
                regionTextAlpha = Math.max(0, Math.min(1, (camera.zoom - REGION_TEXT_FADE_END_ZOOM) / (REGION_TEXT_FADE_START_ZOOM - REGION_TEXT_FADE_END_ZOOM)));
            }

            if (regionTextAlpha > 0) {
                const finalFontSize = Math.min(20 / camera.zoom, MAX_REGION_FONT_SIZE);
                ctx.fillStyle = `rgba(255, 255, 255, ${regionTextAlpha})`;
                ctx.font = `bold ${finalFontSize}px Inter`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.shadowColor = `rgba(0, 0, 0, ${regionTextAlpha * 0.7})`;
                ctx.shadowBlur = 5;
                regionTextToDraw.forEach(item => { ctx.fillText(item.text, item.x, item.y); });
                ctx.shadowBlur = 0;
            }
        }

        function drawSystemView() {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            if (!system) return;

            // Draw orbits
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 1 / camera.zoom;
            system.celestialBodies.forEach(body => {
                if (body.type === 'planet') {
                    ctx.beginPath();
                    ctx.arc(0, 0, body.orbitRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            });

            // Draw bodies
            system.celestialBodies.forEach(body => {
                let x = 0, y = 0;
                if (body.type === 'planet') {
                    x = Math.cos(body.orbitAngle) * body.orbitRadius;
                    y = Math.sin(body.orbitAngle) * body.orbitRadius;
                } else if (body.type === 'asteroid') {
                    x = body.x;
                    y = body.y;
                } else if (body.type === 'asteroid_field') {
                    drawAsteroidField(body, editorState.selectedCelestialBodyId === body.id);
                }

                if (body.type !== 'asteroid_field') {
                    drawCelestialBody(body, x, y);
                }

                if (body.type === 'planet' && body.moons) {
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
                    body.moons.forEach(moon => {
                        ctx.beginPath();
                        ctx.arc(x, y, moon.orbitRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                    });
                    body.moons.forEach(moon => {
                        const moonX = x + Math.cos(moon.orbitAngle) * moon.orbitRadius;
                        const moonY = y + Math.sin(moon.orbitAngle) * moon.orbitRadius;
                        drawCelestialBody(moon, moonX, moonY);
                    });
                }
            });

            if (editorState.drawingAstField) {
                const { x, y, radius } = editorState.drawingAstField;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.stroke();
            }
        }

        function createAsteroidShape(size) {
            const points = [], numPoints = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const dist = size * (0.7 + Math.random() * 0.3);
                points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
            }
            return points;
        }

        function drawAsteroidField(field, isSelected) {
            ctx.beginPath();
            ctx.arc(field.x, field.y, field.radius, 0, 2 * Math.PI);
            ctx.fillStyle = "rgba(156, 163, 175, 0.05)";
            ctx.fill();
            if (isSelected) {
                ctx.strokeStyle = '#fde047';
                ctx.lineWidth = 3 / camera.zoom;
                ctx.stroke();
            }
            ctx.fillStyle = '#6b7280';
            (field.asteroids || []).forEach(ast => {
                const x = field.x + ast.x;
                const y = field.y + ast.y;
                ctx.beginPath();
                ast.shape.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(x + p.x, y + p.y);
                    else ctx.lineTo(x + p.x, y + p.y);
                });
                ctx.closePath();
                ctx.fill();
            });
        }

        function populateRegionsPanel() {
            regionList.innerHTML = '';
            regions.forEach(region => {
                const item = document.createElement('div');
                item.className = 'region-item';
                item.dataset.regionId = region.id;

                const nameSpan = document.createElement('span');
                nameSpan.textContent = region.name;
                nameSpan.style.flexGrow = '1';
                nameSpan.addEventListener('dblclick', () => {
                    const currentName = nameSpan.textContent;
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.className = 'region-name-input';
                    input.value = currentName;
                    item.replaceChild(input, nameSpan);
                    input.focus();
                    input.select();

                    const saveName = () => {
                        const newName = input.value.trim();
                        if (newName && newName !== currentName) {
                            region.name = newName;
                            saveState();
                        }
                        nameSpan.textContent = region.name;
                        item.replaceChild(nameSpan, input);
                    };

                    input.addEventListener('blur', saveName);
                    input.addEventListener('keydown', e => {
                        if (e.key === 'Enter') {
                            input.blur();
                        } else if (e.key === 'Escape') {
                            input.value = currentName;
                            input.blur();
                        }
                    });
                });

                const colorInput = document.createElement('input');
                colorInput.type = 'color';
                colorInput.className = 'region-color-input';
                const rgba = region.color.match(/(\d+(\.\d+)?)/g);
                if (rgba) {
                    const r = parseInt(rgba[0]).toString(16).padStart(2, '0');
                    const g = parseInt(rgba[1]).toString(16).padStart(2, '0');
                    const b = parseInt(rgba[2]).toString(16).padStart(2, '0');
                    colorInput.value = `#${r}${g}${b}`;
                }

                colorInput.addEventListener('input', (e) => {
                    const hex = e.target.value;
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    region.color = `rgba(${r}, ${g}, ${b}, 0.2)`;
                });

                colorInput.addEventListener('change', () => saveState());

                item.appendChild(nameSpan);
                item.appendChild(colorInput);
                regionList.appendChild(item);
            });
        }

        function populateRegionAssignSelect() {
            while (regionAssignSelect.options.length > 1) {
                regionAssignSelect.remove(1);
            }
            regions.forEach(region => {
                const option = document.createElement('option');
                option.value = region.id;
                option.textContent = region.name;
                regionAssignSelect.appendChild(option);
            });

            let commonRegionId = -1;
            if (editorState.selection.length > 0) {
                const firstStarRegion = regions.find(r => r.starIds.includes(editorState.selection[0]));
                if (firstStarRegion) {
                    if (editorState.selection.every(starId => firstStarRegion.starIds.includes(starId))) {
                        commonRegionId = firstStarRegion.id;
                    }
                }
            }
            regionAssignSelect.value = commonRegionId;
        }

        function assignSelectionToRegion(regionId) {
            const starIdsToAssign = editorState.selection;
            regions.forEach(r => {
                r.starIds = r.starIds.filter(id => !starIdsToAssign.includes(id));
            });
            if (regionId !== -1) {
                const targetRegion = regions.find(r => r.id === regionId);
                if (targetRegion) {
                    starIdsToAssign.forEach(id => {
                        if (!targetRegion.starIds.includes(id)) {
                            targetRegion.starIds.push(id);
                        }
                    });
                }
            }
            saveState();
        }

        function deleteSelectedBody() {
            if (editorState.view !== 'system' || editorState.selectedCelestialBodyId === null) return;

            const system = stars.find(s => s.id === editorState.activeSystemId);
            if (!system) return;

            const { body: bodyToDelete } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
            if (!bodyToDelete || bodyToDelete.type === 'star') return;

            // Remove from main celestial bodies list
            system.celestialBodies = system.celestialBodies.filter(b => b.id !== bodyToDelete.id);
            // Remove from any parent's moon list
            system.celestialBodies.forEach(planet => {
                if (planet.moons) {
                    planet.moons = planet.moons.filter(m => m.id !== bodyToDelete.id);
                }
            });

            editorState.selectedCelestialBodyId = null;
            updateInfoPanel();
            populateSystemUI();
            saveState();
        }

        function drawCelestialBody(body, x, y) {
            // Draw selection highlight
            if (editorState.selectedCelestialBodyId === body.id) {
                ctx.beginPath();
                ctx.arc(x, y, body.size + (5 / camera.zoom), 0, 2 * Math.PI);
                ctx.strokeStyle = '#fde047';
                ctx.lineWidth = 3 / camera.zoom;
                ctx.stroke();
            }

            ctx.beginPath();
            if (body.type === 'asteroid') {
                if (!body.shape) body.shape = createAsteroidShape(body.size);
                body.shape.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(x + p.x, y + p.y);
                    else ctx.lineTo(x + p.x, y + p.y);
                });
                ctx.closePath();
            } else {
                ctx.arc(x, y, body.size, 0, 2 * Math.PI);
            }

            ctx.fillStyle = body.type === 'star' ? '#fde047' : (body.type === 'planet' ? '#a0c4ff' : '#9ca3af');
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = body.size * 2;
            ctx.fill();
            ctx.shadowBlur = 0;

            if (body.type !== 'asteroid' && body.type !== 'asteroid_field') {
                ctx.fillStyle = '#fff';
                ctx.font = `${12 / camera.zoom}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(body.name, x, y - body.size - (15 / camera.zoom));
            }
        }

        function drawGrid() {
            const worldTopLeft = screenToWorld(0, 0);
            const worldBottomRight = screenToWorld(canvas.clientWidth, canvas.clientHeight);

            let majorSpacing = 100;
            while (majorSpacing * camera.zoom < 50) majorSpacing *= 10;
            while (majorSpacing * camera.zoom > 500) majorSpacing /= 10;
            const minorSpacing = majorSpacing / 10;

            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 1 / camera.zoom;
            for (let x = Math.floor(worldTopLeft.x / minorSpacing) * minorSpacing; x < worldBottomRight.x; x += minorSpacing) {
                if (x % majorSpacing !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(x, worldTopLeft.y);
                    ctx.lineTo(x, worldBottomRight.y);
                    ctx.stroke();
                }
            }
            for (let y = Math.floor(worldTopLeft.y / minorSpacing) * minorSpacing; y < worldBottomRight.y; y += minorSpacing) {
                if (y % majorSpacing !== 0) {
                    ctx.beginPath();
                    ctx.moveTo(worldTopLeft.x, y);
                    ctx.lineTo(worldBottomRight.x, y);
                    ctx.stroke();
                }
            }

            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 2 / camera.zoom;
            for (let x = Math.floor(worldTopLeft.x / majorSpacing) * majorSpacing; x < worldBottomRight.x; x += majorSpacing) {
                ctx.beginPath();
                ctx.moveTo(x, worldTopLeft.y);
                ctx.lineTo(x, worldBottomRight.y);
                ctx.stroke();
            }
            for (let y = Math.floor(worldTopLeft.y / majorSpacing) * majorSpacing; y < worldBottomRight.y; y += majorSpacing) {
                ctx.beginPath();
                ctx.moveTo(worldTopLeft.x, y);
                ctx.lineTo(worldBottomRight.x, y);
                ctx.stroke();
            }

            ctx.strokeStyle = "rgba(79, 170, 255, 0.3)";
            ctx.lineWidth = 3 / camera.zoom;
            ctx.beginPath();
            ctx.moveTo(0, worldTopLeft.y);
            ctx.lineTo(0, worldBottomRight.y);
            ctx.moveTo(worldTopLeft.x, 0);
            ctx.lineTo(worldBottomRight.x, 0);
            ctx.stroke();
        }

        function animate() {
            const zoomDiff = camera.targetZoom - camera.zoom;
            if (Math.abs(zoomDiff) > 0.001) {
                const oldZoom = camera.zoom;
                camera.zoom += zoomDiff * ZOOM_LERP_FACTOR;
                const mouseX = editorState.lastMousePos.x - canvas.clientWidth / 2;
                const mouseY = editorState.lastMousePos.y - canvas.clientHeight / 2;
                camera.x += mouseX / oldZoom - mouseX / camera.zoom;
                camera.y += mouseY / oldZoom - mouseY / camera.zoom;
            } else {
                camera.zoom = camera.targetZoom;
            }

            const worldPos = screenToWorld(editorState.lastMousePos.x, editorState.lastMousePos.y);

            if (editorState.view === 'galaxy') {
                if (editorState.groupDrag) {
                    const dx = worldPos.x - editorState.groupDrag.startX;
                    const dy = worldPos.y - editorState.groupDrag.startY;
                    editorState.groupDrag.initialPositions.forEach((pos, id) => {
                        const star = stars.find(s => s.id === id);
                        if (star) {
                            star.x = pos.x + dx;
                            star.y = pos.y + dy;
                        }
                    });
                    if (editorState.selection.length === 1) updateInfoPanel();
                } else if (editorState.selectionBox) {
                    editorState.selectionBox.x2 = worldPos.x;
                    editorState.selectionBox.y2 = worldPos.y;
                }
                coordsDisplay.textContent = `X: ${worldPos.x.toFixed(1)}, Y: ${worldPos.y.toFixed(1)}`;
                editorState.hoveredStar = editorState.groupDrag ? null : getStarAt(worldPos.x, worldPos.y);
                editorState.hoveredConnection = editorState.hoveredStar ? null : getConnectionAt(worldPos.x, worldPos.y);
            } else {
                if (editorState.draggedBody) {
                    const system = stars.find(s => s.id === editorState.activeSystemId);
                    const { body, parent } = findBodyAndParent(system, editorState.draggedBody.id);
                    if (body) {
                        const targetX = worldPos.x - editorState.draggedBody.offsetX;
                        const targetY = worldPos.y - editorState.draggedBody.offsetY;
                        if (body.type === 'asteroid' || body.type === 'asteroid_field') {
                            body.x = targetX;
                            body.y = targetY;
                        } else {
                            let parentX = 0, parentY = 0;
                            if (parent) {
                                parentX = Math.cos(parent.orbitAngle) * parent.orbitRadius;
                                parentY = Math.sin(parent.orbitAngle) * parent.orbitRadius;
                            }
                            const dx = targetX - parentX, dy = targetY - parentY;
                            body.orbitRadius = Math.sqrt(dx * dx + dy * dy);
                            body.orbitAngle = Math.atan2(dy, dx);
                        }
                        updateInfoPanel();
                    } else {
                        editorState.draggedBody = null;
                    }
                } else if (editorState.drawingAstField) {
                    const dx = worldPos.x - editorState.drawingAstField.x;
                    const dy = worldPos.y - editorState.drawingAstField.y;
                    editorState.drawingAstField.radius = Math.sqrt(dx * dx + dy * dy);
                }
                coordsDisplay.textContent = `X: ${worldPos.x.toFixed(1)}, Y: ${worldPos.y.toFixed(1)}`;
                const system = stars.find(s => s.id === editorState.activeSystemId);
                editorState.hoveredBodyId = editorState.draggedBody ? null : getBodyAt(worldPos.x, worldPos.y, system)?.id ?? null;
            }

            render();
            requestAnimationFrame(animate);
        }

        function onMouseDown(e) {
            if (e.button !== 0) return;
            const worldPos = screenToWorld(e.clientX, e.clientY);

            if (editorState.isSpacebarPan) {
                camera.isDragging = true;
                camera.lastX = e.clientX;
                camera.lastY = e.clientY;
                updateCursor();
                return;
            }

            if (editorState.view === 'galaxy') {
                handleGalaxyMouseDown(e, worldPos);
            } else {
                handleSystemMouseDown(e, worldPos);
            }
        }

        function handleGalaxyMouseDown(e, worldPos) {
            const clickedStar = getStarAt(worldPos.x, worldPos.y);

            if (editorState.mode === 'delete') {
                if (clickedStar) {
                    stars = stars.filter(s => s.id !== clickedStar.id);
                    connections = connections.filter(c => c.p1_id !== clickedStar.id && c.p2_id !== clickedStar.id);
                    editorState.selection = editorState.selection.filter(id => id !== clickedStar.id);
                    saveState();
                } else {
                    const clickedConnection = getConnectionAt(worldPos.x, worldPos.y);
                    if (clickedConnection) {
                        connections = connections.filter(c => c !== clickedConnection);
                        saveState();
                    }
                }
                updateInfoPanel();
                return;
            }

            if (editorState.mode === 'add') {
                pendingStar = { x: worldPos.x, y: worldPos.y };
                nameInput.value = '';
                nameModal.style.display = 'flex';
                nameInput.focus();
                return;
            }

            if (editorState.mode === 'connect') {
                if (clickedStar) {
                    if (!editorState.firstStarForConnection) {
                        editorState.firstStarForConnection = clickedStar;
                    } else {
                        if (editorState.firstStarForConnection.id !== clickedStar.id) {
                            const exists = connections.some(c =>
                                (c.p1_id === editorState.firstStarForConnection.id && c.p2_id === clickedStar.id) ||
                                (c.p1_id === clickedStar.id && c.p2_id === editorState.firstStarForConnection.id)
                            );
                            if (!exists) {
                                connections.push({ p1_id: editorState.firstStarForConnection.id, p2_id: clickedStar.id });
                                saveState();
                            }
                        }
                        editorState.firstStarForConnection = null;
                    }
                } else {
                    editorState.firstStarForConnection = null;
                }
                updateInfoPanel();
                return;
            }

            if (e.ctrlKey && editorState.selection.length > 0) {
                editorState.groupDrag = { startX: worldPos.x, startY: worldPos.y, initialPositions: new Map() };
                editorState.selection.forEach(id => {
                    const s = stars.find(star => star.id === id);
                    if (s) editorState.groupDrag.initialPositions.set(id, { x: s.x, y: s.y });
                });
                updateInfoPanel();
                updateCursor();
                return;
            }

            if (clickedStar) {
                if (!editorState.selection.includes(clickedStar.id)) {
                    editorState.selection = [clickedStar.id];
                }
            } else {
                editorState.selection = [];
                editorState.selectionBox = { x1: worldPos.x, y1: worldPos.y, x2: worldPos.x, y2: worldPos.y };
            }

            updateInfoPanel();
            updateCursor();
        }

        function handleSystemMouseDown(e, worldPos) {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            const clickedBody = getBodyAt(worldPos.x, worldPos.y, system);

            if (editorState.mode === 'delete') {
                if (clickedBody) {
                    system.celestialBodies = system.celestialBodies.filter(b => b.id !== clickedBody.id);
                    system.celestialBodies.forEach(p => {
                        if (p.moons) p.moons = p.moons.filter(m => m.id !== clickedBody.id);
                    });
                    saveState();
                }
                editorState.selectedCelestialBodyId = null;
                updateInfoPanel();
                populateSystemUI();
                return;
            }

            if (editorState.mode === 'add_asteroid') {
                const astCount = system.celestialBodies.filter(b => b.type === 'asteroid').length;
                system.celestialBodies.push({
                    id: nextBodyId++, type: 'asteroid', name: `Asteroid ${astCount + 1}`,
                    x: worldPos.x, y: worldPos.y, size: 1 + Math.random() * 2
                });
                saveState();
                setMode('pan');
                return;
            }

            if (editorState.mode === 'add_asteroid_field') {
                editorState.drawingAstField = { x: worldPos.x, y: worldPos.y, radius: 0 };
                return;
            }

            if (e.ctrlKey && editorState.selectedCelestialBodyId !== null) {
                const { body, parent } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body && body.type !== 'star') {
                    let offsetX, offsetY;
                    if (body.type === 'asteroid' || body.type === 'asteroid_field') {
                        offsetX = worldPos.x - body.x;
                        offsetY = worldPos.y - body.y;
                    } else {
                        let parentX = 0, parentY = 0;
                        if (parent) {
                            parentX = Math.cos(parent.orbitAngle) * parent.orbitRadius;
                            parentY = Math.sin(parent.orbitAngle) * parent.orbitRadius;
                        }
                        const bodyWorldX = parentX + Math.cos(body.orbitAngle) * body.orbitRadius;
                        const bodyWorldY = parentY + Math.sin(body.orbitAngle) * body.orbitRadius;
                        offsetX = worldPos.x - bodyWorldX;
                        offsetY = worldPos.y - bodyWorldY;
                    }
                    editorState.draggedBody = { id: body.id, offsetX: offsetX, offsetY: offsetY };
                    updateInfoPanel();
                    populateSystemUI();
                    updateCursor();
                    return;
                }
            }

            editorState.selectedCelestialBodyId = clickedBody?.id ?? null;
            updateInfoPanel();
            populateSystemUI();
            updateCursor();
        }

        function onMouseMove(e) {
            editorState.lastMousePos = { x: e.clientX, y: e.clientY };
            if (camera.isDragging) {
                const dx = e.clientX - camera.lastX;
                const dy = e.clientY - camera.lastY;
                camera.x -= dx / camera.zoom;
                camera.y -= dy / camera.zoom;
                camera.lastX = e.clientX;
                camera.lastY = e.clientY;
            }
        }

        function onMouseUp(e) {
            if (editorState.groupDrag) {
                editorState.groupDrag = null;
                saveState();
            }
            if (editorState.draggedBody) {
                editorState.draggedBody = null;
                saveState();
            }
            if (editorState.drawingAstField) {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                if (system) {
                    const fieldCount = system.celestialBodies.filter(b => b.type === 'asteroid_field').length;
                    const newField = {
                        id: nextBodyId++,
                        type: 'asteroid_field',
                        name: `Field ${fieldCount + 1}`,
                        ...editorState.drawingAstField,
                        count: 50 + Math.floor(editorState.drawingAstField.radius / 2),
                        asteroids: []
                    };
                    regenerateAsteroidsInField(newField);
                    system.celestialBodies.push(newField);
                    saveState();
                }
                editorState.drawingAstField = null;
                setMode('pan');
            }
            if (editorState.selectionBox) {
                const { x1, y1, x2, y2 } = editorState.selectionBox;
                const minX = Math.min(x1, x2);
                const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2);
                const maxY = Math.max(y1, y2);
                editorState.selection = stars
                    .filter(s => s.x >= minX && s.x <= maxX && s.y >= minY && s.y <= maxY)
                    .map(s => s.id);
                editorState.selectionBox = null;
                updateInfoPanel();
            }
            if (camera.isDragging) {
                camera.isDragging = false;
            }
            updateCursor();
        }

        function onDoubleClick(e) {
            if (editorState.view !== 'galaxy') return;
            const worldPos = screenToWorld(e.clientX, e.clientY);
            const clickedStar = getStarAt(worldPos.x, worldPos.y);
            if (clickedStar) {
                switchToSystemView(clickedStar.id);
            }
        }

        function switchToSystemView(systemId) {
            editorState.view = 'system';
            editorState.activeSystemId = systemId;
            editorState.selection = [];
            editorState.selectedCelestialBodyId = null;
            camera.x = 0;
            camera.y = 0;
            camera.targetZoom = 1.0;
            galaxyUI.style.display = 'none';
            systemUI.style.display = 'flex';
            populateSystemUI();
            updateInfoPanel();
        }

        function switchToGalaxyView() {
            editorState.view = 'galaxy';
            editorState.activeSystemId = null;
            editorState.selection = [];
            editorState.selectedCelestialBodyId = null;
            camera.targetZoom = 0.5;
            galaxyUI.style.display = 'flex';
            systemUI.style.display = 'none';
            updateInfoPanel();
        }

        function findBodyAndParent(system, bodyId) {
            if (!system || bodyId === null) {
                return { body: null, parent: null };
            }
            for (const body of system.celestialBodies) {
                if (body.id === bodyId) {
                    return { body, parent: null };
                }
                if (body.moons) {
                    for (const moon of body.moons) {
                        if (moon.id === bodyId) {
                            return { body: moon, parent: body };
                        }
                    }
                }
            }
            return { body: null, parent: null };
        }

        function populateSystemUI() {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            if (!system) return;

            document.getElementById('systemNameTitle').textContent = system.name;
            const listEl = document.getElementById('celestialBodyList');
            listEl.innerHTML = '';

            let selectedBodyIsPlanet = false;

            system.celestialBodies.forEach(body => {
                const item = document.createElement('div');
                item.className = 'celestial-body-item';
                item.textContent = `[${body.type.charAt(0).toUpperCase()}] ${body.name}`;
                item.dataset.bodyId = body.id;

                if (body.id === editorState.selectedCelestialBodyId) {
                    item.classList.add('selected');
                    if (body.type === 'planet') {
                        selectedBodyIsPlanet = true;
                    }
                }

                item.addEventListener('click', () => {
                    editorState.selectedCelestialBodyId = body.id;
                    updateInfoPanel();
                    populateSystemUI();
                });
                listEl.appendChild(item);

                if (body.moons) {
                    body.moons.forEach(moon => {
                        const moonItem = document.createElement('div');
                        moonItem.className = 'celestial-body-item moon';
                        moonItem.textContent = moon.name;
                        moonItem.dataset.bodyId = moon.id;

                        if (moon.id === editorState.selectedCelestialBodyId) {
                            moonItem.classList.add('selected');
                        }

                        moonItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            editorState.selectedCelestialBodyId = moon.id;
                            updateInfoPanel();
                            populateSystemUI();
                        });
                        listEl.appendChild(moonItem);
                    });
                }
            });

            addMoonBtn.style.display = selectedBodyIsPlanet ? 'block' : 'none';
        }

        function regenerateAsteroidsInField(field) {
            field.asteroids = [];
            let seed = field.id;
            const random = () => {
                var x = Math.sin(seed++) * 10000;
                return x - Math.floor(x);
            };

            for (let i = 0; i < field.count; i++) {
                const angle = random() * 2 * Math.PI;
                const dist = random() * field.radius;
                const size = 0.5 + random() * 1.5;
                field.asteroids.push({
                    x: Math.cos(angle) * dist,
                    y: Math.sin(angle) * dist,
                    shape: createAsteroidShape(size)
                });
            }
        }

        function onWheel(e) {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.01 : 1 / 1.01;
            const newZoom = camera.targetZoom * factor;
            camera.targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
        }

        function onResize() {
            setupCanvasDPI();
        }

        confirmNameBtn.addEventListener('click', () => {
            const name = nameInput.value.trim();
            if (name && pendingStar) {
                const newStar = {
                    id: nextStarId++,
                    name,
                    x: pendingStar.x,
                    y: pendingStar.y,
                    celestialBodies: [{ id: nextBodyId++, type: 'star', name: name, size: 20 }]
                };
                stars.push(newStar);
                pendingStar = null;
                nameModal.style.display = 'none';
                saveState();
            }
        });

        cancelNameBtn.addEventListener('click', () => {
            pendingStar = null;
            nameModal.style.display = 'none';
        });

        nameInput.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                confirmNameBtn.click();
            }
        });

        infoNameInput.addEventListener('blur', () => {
            if (editorState.selection.length === 1) {
                saveState();
            }
        });

        infoNameInput.addEventListener('input', (e) => {
            if (editorState.selection.length === 1) {
                const star = stars.find(s => s.id === editorState.selection[0]);
                if (star) {
                    star.name = e.target.value;
                }
            }
        });

        document.getElementById('asteroidFieldNameInput').addEventListener('input', e => {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
            if (body && body.type === 'asteroid_field') {
                body.name = e.target.value;
            }
        });
        document.getElementById('asteroidFieldNameInput').addEventListener('blur', saveState);

        document.getElementById('asteroidFieldRadiusInput').addEventListener('change', e => {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
            if (body && body.type === 'asteroid_field') {
                body.radius = +e.target.value;
                regenerateAsteroidsInField(body);
                saveState();
            }
        });

        document.getElementById('asteroidFieldCountInput').addEventListener('change', e => {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
            if (body && body.type === 'asteroid_field') {
                body.count = +e.target.value;
                regenerateAsteroidsInField(body);
                saveState();
            }
        });

        ['planet', 'moon'].forEach(type => {
            document.getElementById(`${type}NameInput`).addEventListener('input', e => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body) body.name = e.target.value;
            });
            document.getElementById(`${type}NameInput`).addEventListener('blur', saveState);
            document.getElementById(`${type}OrbitInput`).addEventListener('change', e => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body) {
                    body.orbitRadius = +e.target.value;
                    saveState();
                }
            });
            document.getElementById(`${type}SizeInput`).addEventListener('change', e => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body) {
                    body.size = +e.target.value;
                    saveState();
                }
            });
        });

        window.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') {
                if (e.code === 'Escape') document.activeElement.blur();
                return;
            }
            if (e.code === 'Space' && !editorState.isSpacebarPan) {
                e.preventDefault();
                editorState.isSpacebarPan = true;
                updateCursor();
            }
            if (e.code === 'Escape') {
                e.preventDefault();
                if (editorState.view === 'system') {
                    switchToGalaxyView();
                } else {
                    editorState.selection = [];
                    setMode('pan');
                    updateInfoPanel();
                }
            }
            if (e.key === 'Delete' || e.key === 'Backspace') {
                if (editorState.view === 'system' && editorState.selectedCelestialBodyId !== null) {
                    e.preventDefault();
                    deleteSelectedBody();
                }
            }
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') {
                    e.preventDefault();
                    undo();
                } else if (e.key === 'y' || (e.key === 'Z' && e.shiftKey)) {
                    e.preventDefault();
                    redo();
                }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                editorState.isSpacebarPan = false;
                if (camera.isDragging) camera.isDragging = false;
                updateCursor();
            }
        });

        function saveState() {
            history = history.slice(0, historyIndex + 1);
            const currentState = {
                stars: JSON.parse(JSON.stringify(stars)),
                connections: JSON.parse(JSON.stringify(connections)),
                regions: JSON.parse(JSON.stringify(regions)),
                nextStarId: nextStarId,
                nextBodyId: nextBodyId,
                nextRegionId: nextRegionId
            };
            history.push(currentState);
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
        }

        function loadState(state) {
            stars = JSON.parse(JSON.stringify(state.stars));
            connections = JSON.parse(JSON.stringify(state.connections));
            regions = state.regions ? JSON.parse(JSON.stringify(state.regions)) : [];
            nextStarId = state.nextStarId;
            nextBodyId = state.nextBodyId;
            nextRegionId = state.nextRegionId || 0;
            editorState.selection = [];

            if (editorState.view === 'system' && !stars.find(s => s.id === editorState.activeSystemId)) {
                switchToGalaxyView();
            } else if (editorState.view === 'system') {
                populateSystemUI();
            }

            updateInfoPanel();
            populateRegionsPanel();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        function exportToXML() {
            const galaxyName = galaxyNameInput.value.trim() || "My Galaxy";

            let childrenXml = stars.map(star => {
                const connectionsXml = connections
                    .filter(c => c.p1_id === star.id)
                    .map(c => stars.find(s => s.id === c.p2_id)?.name)
                    .filter(Boolean)
                    .map(name => `<ConnectedTo EntityId2="${name}"/>`)
                    .join('');

                const planetsXml = star.celestialBodies
                    .filter(b => b.type === 'planet')
                    .map(p => {
                        const moonsXml = (p.moons || [])
                            .map(m => `<Entity><Moon/><Name Value="${m.name}"/><Orbit Radius="${m.orbitRadius}"/><Size Value="${m.size}"/></Entity>`)
                            .join('');
                        return `<Entity><Planet/><Name Value="${p.name}"/><Orbit Radius="${p.orbitRadius}"/><Size Value="${p.size}"/><Children>${moonsXml}</Children></Entity>`;
                    }).join('');

                return `<Entity><StarSystem/><Name Value="${star.name}"/><Position3D X="${star.x.toFixed(2)}" Y="${star.y.toFixed(2)}" Z="0.00"/>${connectionsXml}<Children>${planetsXml}</Children></Entity>`;
            }).join('');

            const fullXml = `<?xml version="1.0" encoding="UTF-8"?><Entity><Galaxy/><Name Value="${galaxyName}"/><Children>${childrenXml}</Children></Entity>`;

            const blob = new Blob([fullXml.trim()], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${galaxyName.replace(/ /g, '_')}.xml`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function importFromXML(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");

            stars = [];
            connections = [];
            nextStarId = 0;
            nextBodyId = 0;
            editorState.selection = [];

            const galaxyEntity = xmlDoc.querySelector("Entity:has(> Galaxy)");
            if (!galaxyEntity) {
                alert("Could not find a root <Entity> with a <Galaxy/> tag.");
                return;
            }

            galaxyNameInput.value = galaxyEntity.querySelector("Name")?.getAttribute("Value") || "Imported Galaxy";

            const childrenContainer = galaxyEntity.querySelector("Children");
            if (!childrenContainer) return;

            const starEntities = childrenContainer.querySelectorAll(":scope > Entity:has(> StarSystem)");
            starEntities.forEach(node => {
                const name = node.querySelector("Name")?.getAttribute("Value");
                const pos = node.querySelector("Position3D");

                if (name && pos) {
                    const newStar = {
                        id: nextStarId++,
                        name,
                        x: parseFloat(pos.getAttribute("X")),
                        y: parseFloat(pos.getAttribute("Y")),
                        celestialBodies: [{ id: nextBodyId++, type: 'star', name: name, size: 20 }]
                    };

                    const planetsContainer = node.querySelector(":scope > Children");
                    if (planetsContainer) {
                        planetsContainer.querySelectorAll(":scope > Entity:has(> Planet)").forEach(pNode => {
                            const pName = pNode.querySelector("Name")?.getAttribute("Value");
                            const pOrbit = pNode.querySelector("Orbit")?.getAttribute("Radius");
                            const pSize = pNode.querySelector("Size")?.getAttribute("Value");
                            if (pName && pOrbit && pSize) {
                                const newPlanet = {
                                    id: nextBodyId++, type: 'planet', name: pName, orbitRadius: parseFloat(pOrbit),
                                    size: parseFloat(pSize), orbitAngle: Math.random() * 2 * Math.PI, moons: []
                                };

                                const moonsContainer = pNode.querySelector(":scope > Children");
                                if (moonsContainer) {
                                    moonsContainer.querySelectorAll(":scope > Entity:has(> Moon)").forEach(mNode => {
                                        const mName = mNode.querySelector("Name")?.getAttribute("Value");
                                        const mOrbit = mNode.querySelector("Orbit")?.getAttribute("Radius");
                                        const mSize = mNode.querySelector("Size")?.getAttribute("Value");
                                        if (mName && mOrbit && mSize) {
                                            newPlanet.moons.push({
                                                id: nextBodyId++, type: 'moon', name: mName, orbitRadius: parseFloat(mOrbit),
                                                size: parseFloat(mSize), orbitAngle: Math.random() * 2 * Math.PI
                                            });
                                        }
                                    });
                                }
                                newStar.celestialBodies.push(newPlanet);
                            }
                        });
                    }
                    stars.push(newStar);
                }
            });

            // Second pass for connections
            starEntities.forEach(node => {
                const star1Name = node.querySelector("Name")?.getAttribute("Value");
                const star1 = stars.find(s => s.name === star1Name);
                if (!star1) return;

                node.querySelectorAll("ConnectedTo").forEach(connNode => {
                    const star2Name = connNode.getAttribute("EntityId2");
                    const star2 = stars.find(s => s.name === star2Name);
                    if (star2) {
                        const exists = connections.some(c =>
                            (c.p1_id === star1.id && c.p2_id === star2.id) ||
                            (c.p1_id === star2.id && c.p2_id === star1.id)
                        );
                        if (!exists) {
                            connections.push({ p1_id: star1.id, p2_id: star2.id });
                        }
                    }
                });
            });

            saveState();
            updateInfoPanel();
        }

        function setup() {
            setupCanvasDPI();
            createStarfield();
            createNebulae();
            populateRegionsPanel();
            editorState.lastMousePos = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };

            addStarBtn.addEventListener('click', () => setMode('add'));
            connectStarBtn.addEventListener('click', () => setMode('connect'));
            deleteBtn.addEventListener('click', () => setMode('delete'));
            deleteBodyBtn.addEventListener('click', () => setMode('delete'));
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            exportBtn.addEventListener('click', exportToXML);
            importBtn.addEventListener('click', () => xmlImporter.click());
            backToGalaxyBtn.addEventListener('click', switchToGalaxyView);

            createRegionBtn.addEventListener('click', () => {
                regionNameInput.value = '';
                regionNameModal.style.display = 'flex';
                regionNameInput.focus();
            });

            confirmRegionNameBtn.addEventListener('click', () => {
                const regionName = regionNameInput.value.trim();
                if (regionName) {
                    const newRegion = {
                        id: nextRegionId++,
                        name: regionName,
                        starIds: [],
                        color: REGION_COLORS[nextRegionId % REGION_COLORS.length]
                    };
                    regions.push(newRegion);
                    populateRegionsPanel();
                    saveState();
                }
                regionNameModal.style.display = 'none';
            });

            cancelRegionNameBtn.addEventListener('click', () => {
                regionNameModal.style.display = 'none';
            });

            regionNameInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') confirmRegionNameBtn.click();
                else if (e.key === 'Escape') cancelRegionNameBtn.click();
            });

            regionAssignSelect.addEventListener('change', (e) => {
                assignSelectionToRegion(parseInt(e.target.value, 10));
            });

            addPlanetBtn.addEventListener('click', () => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                if (system) {
                    const planetCount = system.celestialBodies.filter(b => b.type === 'planet').length;
                    system.celestialBodies.push({
                        id: nextBodyId++, type: 'planet', name: `Planet ${planetCount + 1}`,
                        orbitRadius: 50 + planetCount * 40, size: 5 + Math.random() * 5,
                        orbitAngle: Math.random() * 2 * Math.PI, moons: []
                    });
                    populateSystemUI();
                    saveState();
                }
            });

            addMoonBtn.addEventListener('click', () => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body: planet } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (planet && planet.type === 'planet') {
                    if (!planet.moons) planet.moons = [];
                    planet.moons.push({
                        id: nextBodyId++, type: 'moon', name: `Moon ${planet.moons.length + 1}`,
                        orbitRadius: planet.size + 10 + planet.moons.length * 5, size: 1 + Math.random(),
                        orbitAngle: Math.random() * 2 * Math.PI
                    });
                    populateSystemUI();
                    saveState();
                }
            });

            addAsteroidBtn.addEventListener('click', () => setMode('add_asteroid'));
            addAsteroidFieldBtn.addEventListener('click', () => setMode('add_asteroid_field'));

            xmlImporter.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        importFromXML(e.target.result);
                    } catch (err) {
                        console.error("Error parsing XML file:", err);
                        alert("Failed to parse XML file. Check console for details.");
                    }
                };
                reader.readAsText(file);
                event.target.value = null; // Reset for same-file re-upload
            });

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp); // Handle mouse leaving canvas
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            window.addEventListener('resize', onResize);

            setMode('pan');
            saveState(); // Initial state for undo
            animate();
        }

        setup();
    </script>
</body>

</html>