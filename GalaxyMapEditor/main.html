<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Galaxy Map Editor</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000510;
            font-family: 'Inter', sans-serif;
            color: #fff;
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: grab;
        }

        canvas.space-panning {
            cursor: grabbing;
        }

        canvas.adding {
            cursor: crosshair;
        }

        canvas.connecting {
            cursor: pointer;
        }

        canvas.deleting {
            cursor: not-allowed;
        }

        canvas.dragging-star,
        canvas.dragging-planet {
            cursor: move;
        }

        .ui-panel,
        .system-ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(5px);
            padding: 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            flex-direction: column;
            gap: 10px;
            width: 160px;
        }

        .system-ui-panel {
            width: 200px;
        }

        .system-ui-panel h2 {
            margin: 0 0 5px 0;
            font-size: 18px;
            color: #a0c4ff;
            text-align: center;
        }

        .celestial-body-list {
            max-height: 300px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .celestial-body-item {
            background-color: rgba(255, 255, 255, 0.05);
            padding: 8px;
            border-radius: 4px;
            cursor: pointer;
            border-left: 3px solid transparent;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .celestial-body-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .celestial-body-item.selected {
            background-color: rgba(79, 70, 229, 0.3);
            border-left: 3px solid #6366f1;
            font-weight: bold;
        }

        .celestial-body-item.moon {
            padding-left: 20px;
            font-size: 0.9em;
            position: relative;
        }

        .celestial-body-item.moon::before {
            content: 'L';
            position: absolute;
            left: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-family: monospace;
            color: #9ca3af;
        }

        #galaxyNameInput {
            background-color: transparent;
            border: none;
            border-bottom: 1px solid #4b5563;
            color: #a0c4ff;
            font-size: 18px;
            font-weight: bold;
            text-align: center;
            padding: 5px;
            margin-bottom: 5px;
            outline: none;
        }

        #galaxyNameInput:focus {
            border-bottom-color: #6366f1;
        }

        .ui-panel button,
        .system-ui-panel button {
            background-color: #374151;
            color: #e5e7eb;
            border: 1px solid #4b5563;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            transition: background-color 0.2s, border-color 0.2s;
        }

        .ui-panel button:hover,
        .system-ui-panel button:hover {
            background-color: #4b5563;
        }

        .ui-panel button:disabled,
        .system-ui-panel button:disabled {
            background-color: #1f2937;
            color: #4b5563;
            cursor: not-allowed;
        }

        .ui-panel button.active {
            background-color: #4f46e5;
            border-color: #6366f1;
            color: #fff;
            font-weight: bold;
        }

        .ui-panel button.active-delete {
            background-color: #dc2626;
            border-color: #f87171;
            color: #fff;
            font-weight: bold;
        }

        .history-buttons,
        .io-buttons {
            margin-top: 10px;
            border-top: 1px solid #4b5563;
            padding-top: 10px;
            display: flex;
            gap: 10px;
        }

        .history-buttons button,
        .io-buttons button {
            flex-grow: 1;
        }

        .info-panel {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(17, 24, 39, 0.8);
            backdrop-filter: blur(5px);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            width: 220px;
            display: none;
            /* Hidden by default */
        }

        .info-panel h2 {
            margin: 0 0 10px 0;
            color: #a0c4ff;
            font-size: 16px;
        }

        .info-panel p {
            margin: 8px 0;
            font-size: 14px;
            color: #d1d5db;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .info-panel span,
        .info-panel input {
            font-weight: bold;
            color: #fff;
            background-color: transparent;
            border: none;
            text-align: right;
            outline: none;
        }

        .info-panel input {
            background-color: rgba(0, 0, 0, 0.2);
            border-bottom: 1px solid #4b5563;
            padding: 2px 4px;
            width: 120px;
        }

        .info-panel input:focus {
            border-bottom-color: #6366f1;
        }

        .coords-display,
        .hint-display {
            position: absolute;
            bottom: 10px;
            background-color: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #9ca3af;
        }

        .coords-display {
            right: 10px;
        }

        .hint-display {
            left: 10px;
        }

        .hint-display kbd {
            background-color: #374151;
            border: 1px solid #4b5563;
            border-radius: 3px;
            padding: 1px 4px;
            font-family: inherit;
            font-size: 11px;
        }

        .hint-display-move {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.4);
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 12px;
            color: #9ca3af;
        }

        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        .modal-content {
            background-color: #1f2937;
            padding: 25px;
            border-radius: 8px;
            border: 1px solid #4b5563;
            width: 300px;
            text-align: center;
        }

        .modal-content label {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
        }

        .modal-content input {
            width: calc(100% - 20px);
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #4b5563;
            background-color: #374151;
            color: #fff;
            font-size: 14px;
        }

        .modal-content .modal-buttons {
            margin-top: 20px;
            display: flex;
            justify-content: space-around;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>

<body>
    <div id="galaxyUI" class="ui-panel">
        <input type="text" id="galaxyNameInput" value="My Galaxy">
        <button id="addStarBtn">Add System</button>
        <button id="connectStarBtn">Connect</button>
        <button id="deleteBtn">Delete</button>
        <div class="history-buttons">
            <button id="undoBtn">Undo</button>
            <button id="redoBtn">Redo</button>
        </div>
        <div class="io-buttons">
            <button id="importBtn">Import</button>
            <button id="exportBtn">Export</button>
        </div>
    </div>

    <div id="systemUI" class="system-ui-panel" style="display: none;">
        <h2 id="systemNameTitle">System Name</h2>
        <div id="celestialBodyList" class="celestial-body-list"></div>
        <button id="addPlanetBtn">Add Planet</button>
        <button id="addMoonBtn" style="display:none;">Add Moon</button>
        <button id="addAsteroidBtn">Add Asteroid</button>
        <button id="addAsteroidFieldBtn">Add Ast. Field</button>
        <button id="deleteBodyBtn">Delete</button>
        <button id="backToGalaxyBtn">Back to Galaxy</button>
    </div>

    <div id="infoPanel" class="info-panel">
        <h2 id="infoTitle">Selection Info</h2>
        <div id="singleSelectInfo">
            <p>Name: <input type="text" id="infoNameInput"></p>
            <p>Coords: <span id="infoCoords"></span></p>
            <p>Connections: <span id="infoConnections"></span></p>
        </div>
        <div id="planetSelectInfo" style="display: none;">
            <p>Name: <input type="text" id="planetNameInput"></p>
            <p>Orbit: <input type="number" id="planetOrbitInput" step="10"></p>
            <p>Size: <input type="number" id="planetSizeInput" step="0.5"></p>
        </div>
        <div id="moonSelectInfo" style="display: none;">
            <p>Name: <input type="text" id="moonNameInput"></p>
            <p>Orbit: <input type="number" id="moonOrbitInput" step="1"></p>
            <p>Size: <input type="number" id="moonSizeInput" step="0.1"></p>
        </div>
        <div id="multiSelectInfo" style="display: none;">
            <p><span id="multiSelectCount">0</span> systems selected</p>
        </div>
    </div>

    <div id="coordsDisplay" class="coords-display">X: 0, Y: 0</div>
    <div class="hint-display">Hold <kbd>Space</kbd> to Pan</div>
    <div class="hint-display-move">Hold <kbd>Ctrl</kbd> + Drag to Move</div>

    <div id="nameModal" class="modal-backdrop">
        <div class="modal-content">
            <label for="nameInput">Enter System Name:</label>
            <input type="text" id="nameInput" placeholder="e.g., Sol">
            <div class="modal-buttons">
                <button id="confirmNameBtn">Create</button>
                <button id="cancelNameBtn">Cancel</button>
            </div>
        </div>
    </div>

    <input type="file" id="xmlImporter" accept=".xml" style="display: none;">

    <canvas id="galaxyCanvas"></canvas>

    <script>
        const canvas = document.getElementById('galaxyCanvas');
        const ctx = canvas.getContext('2d');

        const MIN_ZOOM = 0.05;
        const MAX_ZOOM = 15.0;
        const ZOOM_LERP_FACTOR = 0.2;
        const TEXT_FADE_START_ZOOM = 0.7; // Below this zoom, text starts fading
        const TEXT_FADE_END_ZOOM = 0.4;   // Below this zoom, text is fully invisible
        let stars = [];
        let connections = [];
        let editorState = {
            mode: 'pan',
            view: 'galaxy',
            activeSystemId: null,
            selectedCelestialBodyId: null,
            draggedBody: null,
            drawingAstField: null,
            isSpacebarPan: false,
            selection: [],
            groupDrag: null,
            selectionBox: null,
            firstStarForConnection: null,
            hoveredStar: null,
            hoveredBodyId: null,
            hoveredConnection: null,
            lastMousePos: { x: 0, y: 0 },
        };
        let camera = {
            x: 0, y: 0,
            zoom: 1.0, targetZoom: 1.0,
            isDragging: false,
            lastX: 0, lastY: 0,
        };
        let nextStarId = 0;
        let nextBodyId = 0;
        let pendingStar = null;

        let history = [];
        let historyIndex = -1;

        const galaxyUI = document.getElementById('galaxyUI');
        const systemUI = document.getElementById('systemUI');
        const backToGalaxyBtn = document.getElementById('backToGalaxyBtn');
        const addPlanetBtn = document.getElementById('addPlanetBtn');
        const addMoonBtn = document.getElementById('addMoonBtn');
        const addAsteroidBtn = document.getElementById('addAsteroidBtn');
        const addAsteroidFieldBtn = document.getElementById('addAsteroidFieldBtn');
        const addStarBtn = document.getElementById('addStarBtn');
        const connectStarBtn = document.getElementById('connectStarBtn');
        const deleteBtn = document.getElementById('deleteBtn');
        const deleteBodyBtn = document.getElementById('deleteBodyBtn');
        const undoBtn = document.getElementById('undoBtn');
        const redoBtn = document.getElementById('redoBtn');
        const importBtn = document.getElementById('importBtn');
        const exportBtn = document.getElementById('exportBtn');
        const xmlImporter = document.getElementById('xmlImporter');
        const galaxyNameInput = document.getElementById('galaxyNameInput');
        const nameModal = document.getElementById('nameModal');
        const nameInput = document.getElementById('nameInput');
        const confirmNameBtn = document.getElementById('confirmNameBtn');
        const cancelNameBtn = document.getElementById('cancelNameBtn');
        const infoPanel = document.getElementById('infoPanel');
        const infoNameInput = document.getElementById('infoNameInput');
        const coordsDisplay = document.getElementById('coordsDisplay');
        const singleSelectInfo = document.getElementById('singleSelectInfo');
        const planetSelectInfo = document.getElementById('planetSelectInfo');
        const moonSelectInfo = document.getElementById('moonSelectInfo');
        const multiSelectInfo = document.getElementById('multiSelectInfo');

        // --- Functions ---

        function setupCanvasDPI() {
            const dpi = window.devicePixelRatio || 1;
            const style = getComputedStyle(canvas);
            const cssWidth = +style.width.slice(0, -2);
            const cssHeight = +style.height.slice(0, -2);
            canvas.setAttribute('width', cssWidth * dpi);
            canvas.setAttribute('height', cssHeight * dpi);
            ctx.scale(dpi, dpi);
        }

        function screenToWorld(x, y) {
            return {
                x: (x - canvas.clientWidth / 2) / camera.zoom + camera.x,
                y: (y - canvas.clientHeight / 2) / camera.zoom + camera.y
            };
        }

        function getStarAt(worldX, worldY) {
            const clickRadius = 15 / camera.zoom;
            for (let i = stars.length - 1; i >= 0; i--) {
                const star = stars[i];
                if (Math.sqrt((worldX - star.x) ** 2 + (worldY - star.y) ** 2) < clickRadius) return star;
            }
            return null;
        }

        function getConnectionAt(worldX, worldY) {
            const clickThreshold = 5 / camera.zoom;
            for (const conn of connections) {
                const p1 = stars.find(s => s.id === conn.p1_id), p2 = stars.find(s => s.id === conn.p2_id);
                if (!p1 || !p2) continue;
                const dx = p2.x - p1.x, dy = p2.y - p1.y, lenSq = dx * dx + dy * dy;
                if (lenSq === 0) continue;
                let t = ((worldX - p1.x) * dx + (worldY - p1.y) * dy) / lenSq;
                t = Math.max(0, Math.min(1, t));
                const closestX = p1.x + t * dx, closestY = p1.y + t * dy;
                if ((worldX - closestX) ** 2 + (worldY - closestY) ** 2 < clickThreshold ** 2) return conn;
            }
            return null;
        }

        function getBodyAt(worldX, worldY, system) {
            if (!system) return null;

            // Prioritize small, solid objects first
            let foundBody = null;

            // Check for planets and their moons
            for (const body of system.celestialBodies) {
                if (body.type !== 'planet') continue;

                let planetX = Math.cos(body.orbitAngle) * body.orbitRadius;
                let planetY = Math.sin(body.orbitAngle) * body.orbitRadius;

                // Check moons first
                if (body.moons) {
                    for (const moon of body.moons) {
                        const moonX = planetX + Math.cos(moon.orbitAngle) * moon.orbitRadius;
                        const moonY = planetY + Math.sin(moon.orbitAngle) * moon.orbitRadius;
                        const moonClickRadius = moon.size + (5 / camera.zoom);
                        if (Math.sqrt((worldX - moonX) ** 2 + (worldY - moonY) ** 2) < moonClickRadius) {
                            return moon;
                        }
                    }
                }

                // Check planet itself
                const clickRadius = body.size + (5 / camera.zoom);
                if (Math.sqrt((worldX - planetX) ** 2 + (worldY - planetY) ** 2) < clickRadius) {
                    return body;
                }
            }

            // Check for individual asteroids and the star
            for (const body of system.celestialBodies) {
                if (body.type === 'asteroid' || body.type === 'star') {
                    let bodyX = body.type === 'star' ? 0 : body.x;
                    let bodyY = body.type === 'star' ? 0 : body.y;
                    const clickRadius = (body.size || 2) + (5 / camera.zoom);
                    if (Math.sqrt((worldX - bodyX) ** 2 + (worldY - bodyY) ** 2) < clickRadius) {
                        return body;
                    }
                }
            }

            // Finally, check for asteroid fields if nothing else was clicked
            for (const body of system.celestialBodies) {
                if (body.type === 'asteroid_field') {
                    const distSq = (worldX - body.x) ** 2 + (worldY - body.y) ** 2;
                    if (distSq < body.radius ** 2) return body;
                }
            }

            return null;
        }

        function setMode(newMode) {
            if (editorState.mode === 'add_asteroid_field' && editorState.drawingAstField) {
                editorState.drawingAstField = null;
            }
            editorState.mode = (editorState.mode === newMode) ? 'pan' : newMode;
            editorState.firstStarForConnection = null;
            addStarBtn.classList.toggle('active', editorState.mode === 'add');
            connectStarBtn.classList.toggle('active', editorState.mode === 'connect');
            deleteBtn.classList.toggle('active-delete', editorState.mode === 'delete');
            deleteBodyBtn.classList.toggle('active-delete', editorState.mode === 'delete');
            addAsteroidBtn.classList.toggle('active', editorState.mode === 'add_asteroid');
            addAsteroidFieldBtn.classList.toggle('active', editorState.mode === 'add_asteroid_field');
            updateCursor();
        }

        function updateCursor() {
            if (editorState.isSpacebarPan) {
                canvas.style.cursor = camera.isDragging ? 'grabbing' : 'grab';
                return;
            }
            let cursor = 'grab';
            if (editorState.groupDrag || editorState.draggedBody) cursor = 'move';
            else if (editorState.mode === 'add' || editorState.mode === 'add_asteroid' || editorState.mode === 'add_asteroid_field') cursor = 'crosshair';
            else if (editorState.mode === 'connect' || editorState.hoveredBodyId !== null) cursor = 'pointer';
            else if (editorState.mode === 'delete') cursor = 'not-allowed';
            canvas.style.cursor = cursor;
        }

        function updateInfoPanel() {
            const allPanels = [singleSelectInfo, multiSelectInfo, planetSelectInfo, moonSelectInfo];
            allPanels.forEach(p => p.style.display = 'none');
            infoPanel.style.display = 'none';

            if (editorState.view === 'galaxy') {
                if (editorState.selection.length === 1) {
                    const star = stars.find(s => s.id === editorState.selection[0]);
                    if (star) {
                        document.getElementById('infoTitle').textContent = "System Info";
                        infoNameInput.value = star.name;
                        document.getElementById('infoCoords').textContent = `X: ${star.x.toFixed(1)}, Y: ${star.y.toFixed(1)}`;
                        const numConnections = connections.filter(c => c.p1_id === star.id || c.p2_id === star.id).length;
                        document.getElementById('infoConnections').textContent = numConnections;
                        singleSelectInfo.style.display = 'block';
                        infoPanel.style.display = 'block';
                    }
                } else if (editorState.selection.length > 1) {
                    document.getElementById('infoTitle').textContent = "Multiple Selected";
                    document.getElementById('multiSelectCount').textContent = editorState.selection.length;
                    multiSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                }
            } else if (editorState.view === 'system') {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);

                if (body?.type === 'planet') {
                    document.getElementById('infoTitle').textContent = "Planet Info";
                    document.getElementById('planetNameInput').value = body.name;
                    document.getElementById('planetOrbitInput').value = body.orbitRadius.toFixed(1);
                    document.getElementById('planetSizeInput').value = body.size;
                    planetSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                } else if (body?.type === 'moon') {
                    document.getElementById('infoTitle').textContent = "Moon Info";
                    document.getElementById('moonNameInput').value = body.name;
                    document.getElementById('moonOrbitInput').value = body.orbitRadius.toFixed(1);
                    document.getElementById('moonSizeInput').value = body.size;
                    moonSelectInfo.style.display = 'block';
                    infoPanel.style.display = 'block';
                }
            }
        }

        function render() {
            ctx.save();
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.fillStyle = '#000510';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            ctx.restore();

            ctx.save();
            ctx.translate(canvas.clientWidth / 2, canvas.clientHeight / 2);
            ctx.scale(camera.zoom, camera.zoom);
            ctx.translate(-camera.x, -camera.y);

            if (editorState.view === 'galaxy') {
                drawGalaxyView();
            } else {
                drawSystemView();
            }

            ctx.restore();
        }

        function drawGalaxyView() {
            drawGrid();
            ctx.lineWidth = 1.5 / camera.zoom;
            connections.forEach(conn => {
                const p1 = stars.find(s => s.id === conn.p1_id), p2 = stars.find(s => s.id === conn.p2_id);
                if (!p1 || !p2) return;
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                ctx.strokeStyle = (editorState.mode === 'delete' && editorState.hoveredConnection === conn) ? '#ef4444' : 'rgba(100, 150, 255, 0.4)';
                ctx.stroke();
            });
            ctx.font = `${12 / camera.zoom}px Inter`;
            ctx.textAlign = 'center';

            // --- START OF TEXT FADING LOGIC ---
            // Calculate the text opacity based on the current zoom level
            let textAlpha = 1.0;
            if (camera.zoom < TEXT_FADE_START_ZOOM) {
                // This formula calculates a value from 0.0 to 1.0 as the zoom moves
                // between the END and START thresholds.
                textAlpha = (camera.zoom - TEXT_FADE_END_ZOOM) / (TEXT_FADE_START_ZOOM - TEXT_FADE_END_ZOOM);
                // Clamp the value to ensure it's between 0 and 1.
                textAlpha = Math.max(0, Math.min(1, textAlpha));
            }
            // --- END OF TEXT FADING LOGIC ---

            stars.forEach(star => {
                // Draw selection highlight
                if (editorState.selection.includes(star.id)) {
                    ctx.beginPath(); ctx.arc(star.x, star.y, (10 / camera.zoom), 0, 2 * Math.PI);
                    ctx.strokeStyle = '#fde047'; ctx.lineWidth = 3 / camera.zoom; ctx.stroke();
                }

                // Draw the star
                ctx.beginPath(); ctx.arc(star.x, star.y, 5 / camera.zoom, 0, 2 * Math.PI);
                const isHovered = editorState.hoveredStar === star, isSelectedForConnection = editorState.firstStarForConnection === star;
                if (editorState.mode === 'delete' && isHovered) {
                    ctx.fillStyle = '#ef4444'; ctx.shadowColor = '#ef4444'; ctx.shadowBlur = 20 / camera.zoom;
                } else if (isHovered || isSelectedForConnection) {
                    ctx.fillStyle = '#fde047'; ctx.shadowColor = '#fde047'; ctx.shadowBlur = 20 / camera.zoom;
                } else {
                    ctx.fillStyle = '#e5e7eb'; ctx.shadowColor = 'rgba(160, 200, 255, 0.8)'; ctx.shadowBlur = 10 / camera.zoom;
                }
                ctx.fill();
                ctx.shadowBlur = 0;

                // --- MODIFIED --- Draw the text label using the calculated opacity
                if (textAlpha > 0) {
                    ctx.fillStyle = `rgba(209, 213, 219, ${textAlpha})`; // Use rgba to apply opacity
                    ctx.fillText(star.name, star.x, star.y - 15 / camera.zoom);
                }
            });

            // Draw selection box
            if (editorState.selectionBox) {
                ctx.fillStyle = "rgba(79, 170, 255, 0.2)";
                ctx.strokeStyle = "rgba(129, 199, 255, 0.8)";
                ctx.lineWidth = 1 / camera.zoom;
                const { x1, y1, x2, y2 } = editorState.selectionBox;
                ctx.fillRect(x1, y1, x2 - x1, y2 - y1);
                ctx.strokeRect(x1, y1, x2 - x1, y2 - y1);
            }
        }

        function drawSystemView() {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            if (!system) return;

            // Draw planetary orbits around the star
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 1 / camera.zoom;
            system.celestialBodies.forEach(body => {
                if (body.type === 'planet') {
                    ctx.beginPath();
                    ctx.arc(0, 0, body.orbitRadius, 0, 2 * Math.PI);
                    ctx.stroke();
                }
            });

            // Draw all bodies
            system.celestialBodies.forEach(body => {
                let x = 0, y = 0;
                if (body.type === 'planet') {
                    x = Math.cos(body.orbitAngle) * body.orbitRadius;
                    y = Math.sin(body.orbitAngle) * body.orbitRadius;
                } else if (body.type === 'asteroid') {
                    x = body.x;
                    y = body.y;
                } else if (body.type === 'asteroid_field') {
                    const isSelected = editorState.selectedCelestialBodyId === body.id;
                    drawAsteroidField(body, isSelected);
                }

                if (body.type !== 'asteroid_field') drawCelestialBody(body, x, y);

                if (body.type === 'planet' && body.moons) {
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
                    body.moons.forEach(moon => {
                        ctx.beginPath();
                        ctx.arc(x, y, moon.orbitRadius, 0, 2 * Math.PI);
                        ctx.stroke();
                    });
                    body.moons.forEach(moon => {
                        const moonX = x + Math.cos(moon.orbitAngle) * moon.orbitRadius;
                        const moonY = y + Math.sin(moon.orbitAngle) * moon.orbitRadius;
                        drawCelestialBody(moon, moonX, moonY);
                    });
                }
            });

            // Draw temporary asteroid field radius
            if (editorState.drawingAstField) {
                const { x, y, radius } = editorState.drawingAstField;
                ctx.beginPath();
                ctx.arc(x, y, radius, 0, 2 * Math.PI);
                ctx.strokeStyle = "rgba(255, 255, 255, 0.5)";
                ctx.stroke();
            }
        }

        function createAsteroidShape(size) {
            const points = [];
            const numPoints = 5 + Math.floor(Math.random() * 4);
            for (let i = 0; i < numPoints; i++) {
                const angle = (i / numPoints) * 2 * Math.PI;
                const dist = size * (0.7 + Math.random() * 0.3);
                points.push({ x: Math.cos(angle) * dist, y: Math.sin(angle) * dist });
            }
            return points;
        }

        function drawAsteroidField(field, isSelected) {
            ctx.beginPath();
            ctx.arc(field.x, field.y, field.radius, 0, 2 * Math.PI);
            ctx.fillStyle = "rgba(156, 163, 175, 0.05)";
            ctx.fill();

            if (isSelected) {
                ctx.strokeStyle = '#fde047';
                ctx.lineWidth = 3 / camera.zoom;
                ctx.stroke();
            }

            ctx.fillStyle = '#6b7280';
            (field.asteroids || []).forEach(ast => {
                const x = field.x + ast.x;
                const y = field.y + ast.y;
                ctx.beginPath();
                ast.shape.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(x + p.x, y + p.y);
                    else ctx.lineTo(x + p.x, y + p.y);
                });
                ctx.closePath();
                ctx.fill();
            });
        }

        function deleteSelectedBody() {
            if (editorState.view !== 'system' || editorState.selectedCelestialBodyId === null) {
                return;
            }

            const system = stars.find(s => s.id === editorState.activeSystemId);
            if (!system) return;

            const { body: bodyToDelete } = findBodyAndParent(system, editorState.selectedCelestialBodyId);

            // Make sure we found a body and it's not the central star
            if (!bodyToDelete || bodyToDelete.type === 'star') {
                return;
            }

            // Filter the main celestial bodies array
            system.celestialBodies = system.celestialBodies.filter(b => b.id !== bodyToDelete.id);

            // If the deleted body was a planet, we don't need to do anything else.
            // If it was a moon, we need to remove it from its parent planet's `moons` array.
            system.celestialBodies.forEach(planet => {
                if (planet.moons) {
                    planet.moons = planet.moons.filter(m => m.id !== bodyToDelete.id);
                }
            });

            // Reset selection and update UI
            editorState.selectedCelestialBodyId = null;
            updateInfoPanel();
            populateSystemUI();
            saveState();
        }


        function drawCelestialBody(body, x, y) {
            if (editorState.selectedCelestialBodyId === body.id) {
                ctx.beginPath();
                ctx.arc(x, y, body.size + (5 / camera.zoom), 0, 2 * Math.PI);
                ctx.strokeStyle = '#fde047'; ctx.lineWidth = 3 / camera.zoom; ctx.stroke();
            }
            ctx.beginPath();
            if (body.type === 'asteroid') {
                if (!body.shape) body.shape = createAsteroidShape(body.size);
                body.shape.forEach((p, i) => {
                    if (i === 0) ctx.moveTo(x + p.x, y + p.y);
                    else ctx.lineTo(x + p.x, y + p.y);
                });
                ctx.closePath();
            } else {
                ctx.arc(x, y, body.size, 0, 2 * Math.PI);
            }
            ctx.fillStyle = body.type === 'star' ? '#fde047' : (body.type === 'planet' ? '#a0c4ff' : '#9ca3af');
            ctx.shadowColor = ctx.fillStyle;
            ctx.shadowBlur = body.size * 2;
            ctx.fill();
            ctx.shadowBlur = 0;

            if (body.type !== 'asteroid') {
                ctx.fillStyle = '#fff';
                ctx.font = `${12 / camera.zoom}px Inter`;
                ctx.textAlign = 'center';
                ctx.fillText(body.name, x, y - body.size - (15 / camera.zoom));
            }
        }

        function drawGrid() {
            const worldTopLeft = screenToWorld(0, 0);
            const worldBottomRight = screenToWorld(canvas.clientWidth, canvas.clientHeight);
            let majorSpacing = 100;
            while (majorSpacing * camera.zoom < 50) majorSpacing *= 10;
            while (majorSpacing * camera.zoom > 500) majorSpacing /= 10;
            const minorSpacing = majorSpacing / 10;
            ctx.strokeStyle = "rgba(255, 255, 255, 0.05)";
            ctx.lineWidth = 1 / camera.zoom;
            for (let x = Math.floor(worldTopLeft.x / minorSpacing) * minorSpacing; x < worldBottomRight.x; x += minorSpacing) {
                if (x % majorSpacing !== 0) { ctx.beginPath(); ctx.moveTo(x, worldTopLeft.y); ctx.lineTo(x, worldBottomRight.y); ctx.stroke(); }
            }
            for (let y = Math.floor(worldTopLeft.y / minorSpacing) * minorSpacing; y < worldBottomRight.y; y += minorSpacing) {
                if (y % majorSpacing !== 0) { ctx.beginPath(); ctx.moveTo(worldTopLeft.x, y); ctx.lineTo(worldBottomRight.x, y); ctx.stroke(); }
            }
            ctx.strokeStyle = "rgba(255, 255, 255, 0.1)";
            ctx.lineWidth = 2 / camera.zoom;
            for (let x = Math.floor(worldTopLeft.x / majorSpacing) * majorSpacing; x < worldBottomRight.x; x += majorSpacing) {
                ctx.beginPath(); ctx.moveTo(x, worldTopLeft.y); ctx.lineTo(x, worldBottomRight.y); ctx.stroke();
            }
            for (let y = Math.floor(worldTopLeft.y / majorSpacing) * majorSpacing; y < worldBottomRight.y; y += majorSpacing) {
                ctx.beginPath(); ctx.moveTo(worldTopLeft.x, y); ctx.lineTo(worldBottomRight.x, y); ctx.stroke();
            }
            ctx.strokeStyle = "rgba(79, 170, 255, 0.3)";
            ctx.lineWidth = 3 / camera.zoom;
            ctx.beginPath();
            ctx.moveTo(0, worldTopLeft.y); ctx.lineTo(0, worldBottomRight.y);
            ctx.moveTo(worldTopLeft.x, 0); ctx.lineTo(worldBottomRight.x, 0);
            ctx.stroke();
        }

        function animate() {
            const zoomDiff = camera.targetZoom - camera.zoom;
            if (Math.abs(zoomDiff) > 0.001) {
                const oldZoom = camera.zoom;
                camera.zoom += zoomDiff * ZOOM_LERP_FACTOR;
                const mouseX = editorState.lastMousePos.x - canvas.clientWidth / 2;
                const mouseY = editorState.lastMousePos.y - canvas.clientHeight / 2;
                camera.x += mouseX / oldZoom - mouseX / camera.zoom;
                camera.y += mouseY / oldZoom - mouseY / camera.zoom;
            } else { camera.zoom = camera.targetZoom; }

            const worldPos = screenToWorld(editorState.lastMousePos.x, editorState.lastMousePos.y);

            if (editorState.view === 'galaxy') {
                if (editorState.groupDrag) {
                    const dx = worldPos.x - editorState.groupDrag.startX;
                    const dy = worldPos.y - editorState.groupDrag.startY;
                    editorState.groupDrag.initialPositions.forEach((pos, id) => {
                        const star = stars.find(s => s.id === id);
                        if (star) { star.x = pos.x + dx; star.y = pos.y + dy; }
                    });
                    if (editorState.selection.length === 1) updateInfoPanel();
                } else if (editorState.selectionBox) {
                    editorState.selectionBox.x2 = worldPos.x;
                    editorState.selectionBox.y2 = worldPos.y;
                }
                coordsDisplay.textContent = `X: ${worldPos.x.toFixed(1)}, Y: ${worldPos.y.toFixed(1)}`;
                editorState.hoveredStar = editorState.groupDrag ? null : getStarAt(worldPos.x, worldPos.y);
                editorState.hoveredConnection = editorState.hoveredStar ? null : getConnectionAt(worldPos.x, worldPos.y);
            } else { // System view
                // --- Start of FIX ---
                if (editorState.draggedBody) {
                    const system = stars.find(s => s.id === editorState.activeSystemId);
                    const { body, parent } = findBodyAndParent(system, editorState.draggedBody.id);

                    if (body) {
                        const targetX = worldPos.x - editorState.draggedBody.offsetX;
                        const targetY = worldPos.y - editorState.draggedBody.offsetY;

                        if (body.type === 'asteroid' || body.type === 'asteroid_field') {
                            body.x = targetX;
                            body.y = targetY;
                        } else { // planet or moon
                            let parentX = 0, parentY = 0;
                            if (parent) {
                                parentX = Math.cos(parent.orbitAngle) * parent.orbitRadius;
                                parentY = Math.sin(parent.orbitAngle) * parent.orbitRadius;
                            }
                            const dx = targetX - parentX;
                            const dy = targetY - parentY;
                            body.orbitRadius = Math.sqrt(dx * dx + dy * dy);
                            body.orbitAngle = Math.atan2(dy, dx);
                        }
                        updateInfoPanel();
                    } else {
                        // Body was probably deleted, stop the drag.
                        editorState.draggedBody = null;
                    }
                    // --- End of FIX ---
                } else if (editorState.drawingAstField) {
                    const dx = worldPos.x - editorState.drawingAstField.x;
                    const dy = worldPos.y - editorState.drawingAstField.y;
                    editorState.drawingAstField.radius = Math.sqrt(dx * dx + dy * dy);
                }
                coordsDisplay.textContent = `X: ${worldPos.x.toFixed(1)}, Y: ${worldPos.y.toFixed(1)}`;
                const system = stars.find(s => s.id === editorState.activeSystemId);
                editorState.hoveredBodyId = editorState.draggedBody ? null : getBodyAt(worldPos.x, worldPos.y, system)?.id ?? null;
            }

            render();
            requestAnimationFrame(animate);
        }

        function onMouseDown(e) {
            if (e.button !== 0) return;
            const worldPos = screenToWorld(e.clientX, e.clientY);

            if (editorState.isSpacebarPan) {
                camera.isDragging = true; camera.lastX = e.clientX; camera.lastY = e.clientY;
                updateCursor(); return;
            }

            if (editorState.view === 'galaxy') {
                handleGalaxyMouseDown(e, worldPos);
            } else {
                handleSystemMouseDown(e, worldPos);
            }
        }

        function handleGalaxyMouseDown(e, worldPos) {
            const clickedStar = getStarAt(worldPos.x, worldPos.y);
            if (editorState.mode === 'delete') {
                if (clickedStar) {
                    stars = stars.filter(s => s.id !== clickedStar.id);
                    connections = connections.filter(c => c.p1_id !== clickedStar.id && c.p2_id !== clickedStar.id);
                    editorState.selection = editorState.selection.filter(id => id !== clickedStar.id);
                    saveState();
                } else {
                    const clickedConnection = getConnectionAt(worldPos.x, worldPos.y);
                    if (clickedConnection) {
                        connections = connections.filter(c => c !== clickedConnection);
                        saveState();
                    }
                }
                updateInfoPanel();
                return;
            }

            if (editorState.mode === 'add') {
                pendingStar = { x: worldPos.x, y: worldPos.y };
                nameInput.value = ''; nameModal.style.display = 'flex'; nameInput.focus();
                return;
            }

            if (editorState.mode === 'connect') {
                if (clickedStar) {
                    if (!editorState.firstStarForConnection) editorState.firstStarForConnection = clickedStar;
                    else {
                        if (editorState.firstStarForConnection.id !== clickedStar.id) {
                            const exists = connections.some(c => (c.p1_id === editorState.firstStarForConnection.id && c.p2_id === clickedStar.id) || (c.p1_id === clickedStar.id && c.p2_id === editorState.firstStarForConnection.id));
                            if (!exists) {
                                connections.push({ p1_id: editorState.firstStarForConnection.id, p2_id: clickedStar.id });
                                saveState();
                            }
                        }
                        editorState.firstStarForConnection = null;
                    }
                } else {
                    editorState.firstStarForConnection = null;
                }
                updateInfoPanel();
                return;
            }

            // Handle Ctrl+drag for moving selected objects from anywhere on canvas
            if (e.ctrlKey && editorState.selection.length > 0) {
                // Start dragging selected objects regardless of what was clicked
                editorState.groupDrag = {
                    startX: worldPos.x,
                    startY: worldPos.y,
                    initialPositions: new Map()
                };
                editorState.selection.forEach(id => {
                    const s = stars.find(star => star.id === id);
                    if (s) editorState.groupDrag.initialPositions.set(id, { x: s.x, y: s.y });
                });
                updateInfoPanel();
                updateCursor();
                return;
            }

            // Handle star selection
            if (clickedStar) {
                // If clicking on an unselected star, select it
                if (!editorState.selection.includes(clickedStar.id)) {
                    editorState.selection = [clickedStar.id];
                }
            } else {
                // Clicking on empty space - start selection box
                editorState.selection = [];
                editorState.selectionBox = { x1: worldPos.x, y1: worldPos.y, x2: worldPos.x, y2: worldPos.y };
            }

            updateInfoPanel();
            updateCursor();
        }

        function handleSystemMouseDown(e, worldPos) {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            const clickedBody = getBodyAt(worldPos.x, worldPos.y, system);

            if (editorState.mode === 'delete') {
                if (clickedBody) {
                    system.celestialBodies = system.celestialBodies.filter(b => b.id !== clickedBody.id);
                    system.celestialBodies.forEach(p => {
                        if (p.moons) p.moons = p.moons.filter(m => m.id !== clickedBody.id);
                    });
                    saveState();
                }
                editorState.selectedCelestialBodyId = null;
                updateInfoPanel();
                populateSystemUI();
                return;
            }

            if (editorState.mode === 'add_asteroid') {
                const astCount = system.celestialBodies.filter(b => b.type === 'asteroid').length;
                system.celestialBodies.push({
                    id: nextBodyId++, type: 'asteroid', name: `Asteroid ${astCount + 1}`,
                    x: worldPos.x, y: worldPos.y, size: 1 + Math.random() * 2
                });
                saveState();
                setMode('pan');
                return;
            }

            if (editorState.mode === 'add_asteroid_field') {
                editorState.drawingAstField = { x: worldPos.x, y: worldPos.y, radius: 0 };
                return;
            }

            // --- Start of FIX ---
            // Handle Ctrl+drag for moving selected celestial body from anywhere on canvas
            if (e.ctrlKey && editorState.selectedCelestialBodyId !== null) {
                const { body, parent } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body && body.type !== 'star') {
                    let offsetX, offsetY;
                    if (body.type === 'asteroid' || body.type === 'asteroid_field') {
                        offsetX = worldPos.x - body.x;
                        offsetY = worldPos.y - body.y;
                    } else { // planet or moon
                        let parentX = 0, parentY = 0;
                        if (parent) {
                            parentX = Math.cos(parent.orbitAngle) * parent.orbitRadius;
                            parentY = Math.sin(parent.orbitAngle) * parent.orbitRadius;
                        }
                        const bodyWorldX = parentX + Math.cos(body.orbitAngle) * body.orbitRadius;
                        const bodyWorldY = parentY + Math.sin(body.orbitAngle) * body.orbitRadius;
                        offsetX = worldPos.x - bodyWorldX;
                        offsetY = worldPos.y - bodyWorldY;
                    }

                    // The 'draggedBody' state object now holds the ID and the offset
                    editorState.draggedBody = {
                        id: body.id,
                        offsetX: offsetX,
                        offsetY: offsetY
                    };

                    updateInfoPanel();
                    populateSystemUI();
                    updateCursor();
                    return;
                }
            }
            // --- End of FIX ---

            // Handle celestial body selection
            editorState.selectedCelestialBodyId = clickedBody?.id ?? null;

            updateInfoPanel();
            populateSystemUI();
            updateCursor();
        }

        function onMouseMove(e) {
            editorState.lastMousePos = { x: e.clientX, y: e.clientY };
            if (camera.isDragging) {
                const dx = e.clientX - camera.lastX, dy = e.clientY - camera.lastY;
                camera.x -= dx / camera.zoom; camera.y -= dy / camera.zoom;
                camera.lastX = e.clientX; camera.lastY = e.clientY;
            }
        }

        function onMouseUp(e) {
            if (editorState.groupDrag) {
                editorState.groupDrag = null;
                saveState();
            }
            if (editorState.draggedBody) {
                editorState.draggedBody = null;
                saveState();
            }
            if (editorState.drawingAstField) {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                if (system) {
                    const fieldCount = system.celestialBodies.filter(b => b.type === 'asteroid_field').length;
                    const newField = {
                        id: nextBodyId++, type: 'asteroid_field', name: `Field ${fieldCount + 1}`,
                        ...editorState.drawingAstField,
                        count: 50 + Math.floor(editorState.drawingAstField.radius / 2),
                        asteroids: []
                    };

                    let seed = newField.id;
                    const random = () => {
                        var x = Math.sin(seed++) * 10000;
                        return x - Math.floor(x);
                    };

                    for (let i = 0; i < newField.count; i++) {
                        const angle = random() * 2 * Math.PI;
                        const dist = random() * newField.radius;
                        const size = 0.5 + random() * 1.5;
                        newField.asteroids.push({
                            x: Math.cos(angle) * dist,
                            y: Math.sin(angle) * dist,
                            shape: createAsteroidShape(size)
                        });
                    }
                    system.celestialBodies.push(newField);
                    saveState();
                }
                editorState.drawingAstField = null;
                setMode('pan');
            }
            if (editorState.selectionBox) {
                const { x1, y1, x2, y2 } = editorState.selectionBox;
                const minX = Math.min(x1, x2); const maxX = Math.max(x1, x2);
                const minY = Math.min(y1, y2); const maxY = Math.max(y1, y2);
                const newSelection = stars.filter(s => s.x >= minX && s.x <= maxX && s.y >= minY && s.y <= maxY).map(s => s.id);
                editorState.selection = newSelection;
                editorState.selectionBox = null;
                updateInfoPanel();
            }
            if (camera.isDragging) {
                camera.isDragging = false;
            }
            updateCursor();
        }

        function onDoubleClick(e) {
            if (editorState.view !== 'galaxy') return;
            const worldPos = screenToWorld(e.clientX, e.clientY);
            const clickedStar = getStarAt(worldPos.x, worldPos.y);
            if (clickedStar) {
                switchToSystemView(clickedStar.id);
            }
        }

        function switchToSystemView(systemId) {
            editorState.view = 'system';
            editorState.activeSystemId = systemId;
            editorState.selection = [];
            editorState.selectedCelestialBodyId = null;
            camera.x = 0; camera.y = 0;
            camera.targetZoom = 1.0;
            galaxyUI.style.display = 'none';
            systemUI.style.display = 'flex';
            populateSystemUI();
            updateInfoPanel();
        }

        function switchToGalaxyView() {
            editorState.view = 'galaxy';
            editorState.activeSystemId = null;
            editorState.selection = [];
            editorState.selectedCelestialBodyId = null;
            camera.targetZoom = 0.5;
            galaxyUI.style.display = 'flex';
            systemUI.style.display = 'none';
            updateInfoPanel();
        }

        function findBodyAndParent(system, bodyId) {
            if (!system || bodyId === null) return { body: null, parent: null };
            for (const body of system.celestialBodies) {
                if (body.id === bodyId) return { body, parent: null };
                if (body.moons) {
                    for (const moon of body.moons) {
                        if (moon.id === bodyId) return { body: moon, parent: body };
                    }
                }
            }
            return { body: null, parent: null };
        }

        function populateSystemUI() {
            const system = stars.find(s => s.id === editorState.activeSystemId);
            if (!system) return;

            document.getElementById('systemNameTitle').textContent = system.name;
            const listEl = document.getElementById('celestialBodyList');
            listEl.innerHTML = '';

            let selectedBodyIsPlanet = false;
            system.celestialBodies.forEach(body => {
                const item = document.createElement('div');
                item.className = 'celestial-body-item';
                item.textContent = `[${body.type.charAt(0).toUpperCase()}] ${body.name}`;
                item.dataset.bodyId = body.id;
                if (body.id === editorState.selectedCelestialBodyId) {
                    item.classList.add('selected');
                    if (body.type === 'planet') selectedBodyIsPlanet = true;
                }
                item.addEventListener('click', () => {
                    editorState.selectedCelestialBodyId = body.id;
                    updateInfoPanel();
                    populateSystemUI();
                });
                listEl.appendChild(item);

                if (body.moons) {
                    body.moons.forEach(moon => {
                        const moonItem = document.createElement('div');
                        moonItem.className = 'celestial-body-item moon';
                        moonItem.textContent = moon.name;
                        moonItem.dataset.bodyId = moon.id;
                        if (moon.id === editorState.selectedCelestialBodyId) {
                            moonItem.classList.add('selected');
                        }
                        moonItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            editorState.selectedCelestialBodyId = moon.id;
                            updateInfoPanel();
                            populateSystemUI();
                        });
                        listEl.appendChild(moonItem);
                    });
                }
            });

            addMoonBtn.style.display = selectedBodyIsPlanet ? 'block' : 'none';
        }

        function onWheel(e) {
            e.preventDefault();
            const factor = e.deltaY < 0 ? 1.01 : 1 / 1.01;
            const newZoom = camera.targetZoom * factor;
            camera.targetZoom = Math.max(MIN_ZOOM, Math.min(MAX_ZOOM, newZoom));
        }

        function onResize() { setupCanvasDPI(); }

        confirmNameBtn.addEventListener('click', () => {
            const name = nameInput.value.trim();
            if (name && pendingStar) {
                const newStar = {
                    id: nextStarId++, name, x: pendingStar.x, y: pendingStar.y,
                    celestialBodies: [{ id: nextBodyId++, type: 'star', name: name, size: 20 }]
                };
                stars.push(newStar);
                pendingStar = null; nameModal.style.display = 'none';
                saveState();
            }
        });
        cancelNameBtn.addEventListener('click', () => { pendingStar = null; nameModal.style.display = 'none'; });
        nameInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') confirmNameBtn.click(); });

        infoNameInput.addEventListener('blur', () => { if (editorState.selection.length === 1) saveState(); });
        infoNameInput.addEventListener('input', (e) => {
            if (editorState.selection.length === 1) {
                const star = stars.find(s => s.id === editorState.selection[0]);
                if (star) star.name = e.target.value;
            }
        });

        // Planet & Moon Info Panel listeners
        ['planet', 'moon'].forEach(type => {
            document.getElementById(`${type}NameInput`).addEventListener('input', e => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body) body.name = e.target.value;
            });
            document.getElementById(`${type}NameInput`).addEventListener('blur', saveState);
            document.getElementById(`${type}OrbitInput`).addEventListener('change', e => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body) { body.orbitRadius = +e.target.value; saveState(); }
            });
            document.getElementById(`${type}SizeInput`).addEventListener('change', e => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (body) { body.size = +e.target.value; saveState(); }
            });
        });

        window.addEventListener('keydown', (e) => {
            if (document.activeElement.tagName === 'INPUT') {
                if (e.code === 'Escape') document.activeElement.blur();
                return;
            }
            if (e.code === 'Space' && !editorState.isSpacebarPan) {
                e.preventDefault(); editorState.isSpacebarPan = true; updateCursor();
            }
            if (e.code === 'Escape') {
                e.preventDefault();
                if (editorState.view === 'system') {
                    switchToGalaxyView();
                } else {
                    editorState.selection = []; setMode('pan'); updateInfoPanel();
                }
            }
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 'z') { e.preventDefault(); undo(); }
                else if (e.key === 'y' || (e.key === 'Z' && e.shiftKey)) { e.preventDefault(); redo(); }
            }
        });

        window.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                e.preventDefault(); editorState.isSpacebarPan = false;
                if (camera.isDragging) camera.isDragging = false;
                updateCursor();
            }
        });

        // --- History Functions ---
        function saveState() {
            history = history.slice(0, historyIndex + 1);
            const currentState = {
                stars: JSON.parse(JSON.stringify(stars)),
                connections: JSON.parse(JSON.stringify(connections)),
                nextStarId: nextStarId,
                nextBodyId: nextBodyId
            };
            history.push(currentState);
            historyIndex = history.length - 1;
            updateUndoRedoButtons();
        }

        function loadState(state) {
            stars = JSON.parse(JSON.stringify(state.stars));
            connections = JSON.parse(JSON.stringify(state.connections));
            nextStarId = state.nextStarId;
            nextBodyId = state.nextBodyId;
            editorState.selection = [];
            if (editorState.view === 'system' && !stars.find(s => s.id === editorState.activeSystemId)) {
                switchToGalaxyView();
            } else if (editorState.view === 'system') {
                populateSystemUI();
            }
            updateInfoPanel();
        }

        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                loadState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                loadState(history[historyIndex]);
                updateUndoRedoButtons();
            }
        }

        function updateUndoRedoButtons() {
            undoBtn.disabled = historyIndex <= 0;
            redoBtn.disabled = historyIndex >= history.length - 1;
        }

        // --- XML Import/Export ---
        function exportToXML() {
            const galaxyName = galaxyNameInput.value.trim() || "My Galaxy";

            let childrenXml = stars.map(star => {
                const connectionsXml = connections
                    .filter(c => c.p1_id === star.id)
                    .map(c => stars.find(s => s.id === c.p2_id)?.name)
                    .filter(Boolean)
                    .map(name => `
            <ConnectedTo EntityId2="${name}"/>`).join('');

                const planetsXml = star.celestialBodies
                    .filter(b => b.type === 'planet')
                    .map(p => {
                        const moonsXml = (p.moons || []).map(m => `
                    <Entity>
                        <Moon/>
                        <Name Value="${m.name}"/>
                        <Orbit Radius="${m.orbitRadius}"/>
                        <Size Value="${m.size}"/>
                    </Entity>`).join('');
                        return `
                <Entity>
                    <Planet/>
                    <Name Value="${p.name}"/>
                    <Orbit Radius="${p.orbitRadius}"/>
                    <Size Value="${p.size}"/>
                    <Children>${moonsXml}
                    </Children>
                </Entity>`;
                    }).join('');

                return `
        <Entity>
            <StarSystem/>
            <Name Value="${star.name}"/>
            <Position3D X="${star.x.toFixed(2)}" Y="${star.y.toFixed(2)}" Z="0.00"/>${connectionsXml}
            <Children>${planetsXml}
            </Children>
        </Entity>`;
            }).join('');

            const fullXml = `<?xml version="1.0" encoding="UTF-8"?>
<Entity>
    <Galaxy/>
    <Name Value="${galaxyName}"/>
    <Children>${childrenXml}
    </Children>
</Entity>`;

            const blob = new Blob([fullXml.trim()], { type: 'application/xml' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${galaxyName.replace(/ /g, '_')}.xml`;
            document.body.appendChild(a); a.click();
            document.body.removeChild(a); URL.revokeObjectURL(url);
        }

        function importFromXML(xmlString) {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(xmlString, "application/xml");

            stars = []; connections = [];
            nextStarId = 0; nextBodyId = 0;
            editorState.selection = [];

            const galaxyEntity = xmlDoc.querySelector("Entity:has(> Galaxy)");
            if (!galaxyEntity) { alert("Could not find a root <Entity> with a <Galaxy/> tag."); return; }
            galaxyNameInput.value = galaxyEntity.querySelector("Name")?.getAttribute("Value") || "Imported Galaxy";

            const childrenContainer = galaxyEntity.querySelector("Children");
            if (!childrenContainer) return;

            const starEntities = childrenContainer.querySelectorAll(":scope > Entity:has(> StarSystem)");
            starEntities.forEach(node => {
                const name = node.querySelector("Name")?.getAttribute("Value");
                const pos = node.querySelector("Position3D");
                if (name && pos) {
                    const newStar = {
                        id: nextStarId++, name,
                        x: parseFloat(pos.getAttribute("X")),
                        y: parseFloat(pos.getAttribute("Y")),
                        celestialBodies: [{ id: nextBodyId++, type: 'star', name: name, size: 20 }]
                    };
                    const planetsContainer = node.querySelector(":scope > Children");
                    if (planetsContainer) {
                        planetsContainer.querySelectorAll(":scope > Entity:has(> Planet)").forEach(pNode => {
                            const pName = pNode.querySelector("Name")?.getAttribute("Value");
                            const pOrbit = pNode.querySelector("Orbit")?.getAttribute("Radius");
                            const pSize = pNode.querySelector("Size")?.getAttribute("Value");
                            if (pName && pOrbit && pSize) {
                                const newPlanet = {
                                    id: nextBodyId++, type: 'planet', name: pName,
                                    orbitRadius: parseFloat(pOrbit), size: parseFloat(pSize),
                                    orbitAngle: Math.random() * 2 * Math.PI, moons: []
                                };
                                const moonsContainer = pNode.querySelector(":scope > Children");
                                if (moonsContainer) {
                                    moonsContainer.querySelectorAll(":scope > Entity:has(> Moon)").forEach(mNode => {
                                        const mName = mNode.querySelector("Name")?.getAttribute("Value");
                                        const mOrbit = mNode.querySelector("Orbit")?.getAttribute("Radius");
                                        const mSize = mNode.querySelector("Size")?.getAttribute("Value");
                                        if (mName && mOrbit && mSize) {
                                            newPlanet.moons.push({
                                                id: nextBodyId++, type: 'moon', name: mName,
                                                orbitRadius: parseFloat(mOrbit), size: parseFloat(mSize),
                                                orbitAngle: Math.random() * 2 * Math.PI
                                            });
                                        }
                                    });
                                }
                                newStar.celestialBodies.push(newPlanet);
                            }
                        });
                    }
                    stars.push(newStar);
                }
            });

            starEntities.forEach(node => {
                const star1Name = node.querySelector("Name")?.getAttribute("Value");
                const star1 = stars.find(s => s.name === star1Name);
                if (!star1) return;
                node.querySelectorAll("ConnectedTo").forEach(connNode => {
                    const star2Name = connNode.getAttribute("EntityId2");
                    const star2 = stars.find(s => s.name === star2Name);
                    if (star2) {
                        const exists = connections.some(c => (c.p1_id === star1.id && c.p2_id === star2.id) || (c.p1_id === star2.id && c.p2_id === star1.id));
                        if (!exists) connections.push({ p1_id: star1.id, p2_id: star2.id });
                    }
                });
            });

            saveState();
            updateInfoPanel();
        }

        function setup() {
            setupCanvasDPI();
            editorState.lastMousePos = { x: canvas.clientWidth / 2, y: canvas.clientHeight / 2 };

            addStarBtn.addEventListener('click', () => setMode('add'));
            connectStarBtn.addEventListener('click', () => setMode('connect'));
            deleteBtn.addEventListener('click', () => setMode('delete'));
            deleteBodyBtn.addEventListener('click', () => setMode('delete'));
            undoBtn.addEventListener('click', undo);
            redoBtn.addEventListener('click', redo);
            exportBtn.addEventListener('click', exportToXML);
            importBtn.addEventListener('click', () => xmlImporter.click());
            backToGalaxyBtn.addEventListener('click', switchToGalaxyView);
            addPlanetBtn.addEventListener('click', () => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                if (system) {
                    const planetCount = system.celestialBodies.filter(b => b.type === 'planet').length;
                    system.celestialBodies.push({
                        id: nextBodyId++, type: 'planet', name: `Planet ${planetCount + 1}`,
                        orbitRadius: 50 + planetCount * 40, size: 5 + Math.random() * 5,
                        orbitAngle: Math.random() * 2 * Math.PI, moons: []
                    });
                    populateSystemUI();
                    saveState();
                }
            });
            addMoonBtn.addEventListener('click', () => {
                const system = stars.find(s => s.id === editorState.activeSystemId);
                const { body: planet } = findBodyAndParent(system, editorState.selectedCelestialBodyId);
                if (planet && planet.type === 'planet') {
                    if (!planet.moons) planet.moons = [];
                    planet.moons.push({
                        id: nextBodyId++, type: 'moon', name: `Moon ${planet.moons.length + 1}`,
                        orbitRadius: planet.size + 10 + planet.moons.length * 5, size: 1 + Math.random(),
                        orbitAngle: Math.random() * 2 * Math.PI
                    });
                    populateSystemUI();
                    saveState();
                }
            });
            addAsteroidBtn.addEventListener('click', () => setMode('add_asteroid'));
            addAsteroidFieldBtn.addEventListener('click', () => setMode('add_asteroid_field'));

            xmlImporter.addEventListener('change', (event) => {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    try { importFromXML(e.target.result); } catch (err) {
                        console.error("Error parsing XML file:", err);
                        alert("Failed to parse XML file. Check console for details.");
                    }
                };
                reader.readAsText(file);
                event.target.value = null;
            });

            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('mouseleave', onMouseUp);
            canvas.addEventListener('dblclick', onDoubleClick);
            canvas.addEventListener('wheel', onWheel, { passive: false });
            window.addEventListener('resize', onResize);
            window.addEventListener('keydown', (e) => {
                if (document.activeElement.tagName === 'INPUT') {
                    if (e.code === 'Escape') document.activeElement.blur();
                    return;
                }
                if (e.code === 'Space' && !editorState.isSpacebarPan) {
                    e.preventDefault(); editorState.isSpacebarPan = true; updateCursor();
                }
                if (e.code === 'Escape') {
                    e.preventDefault();
                    if (editorState.view === 'system') {
                        switchToGalaxyView();
                    } else {
                        editorState.selection = []; setMode('pan'); updateInfoPanel();
                    }
                }

                if (e.key === 'Delete' || e.key === 'Backspace') {
                    if (editorState.view === 'system' && editorState.selectedCelestialBodyId !== null) {
                        e.preventDefault(); // Prevents browser back navigation on backspace
                        deleteSelectedBody();
                    }
                }

                if (e.ctrlKey || e.metaKey) {
                    if (e.key === 'z') { e.preventDefault(); undo(); }
                    else if (e.key === 'y' || (e.key === 'Z' && e.shiftKey)) { e.preventDefault(); redo(); }
                }
            });
            window.addEventListener('keyup', (e) => {
                if (e.code === 'Space') {
                    e.preventDefault(); editorState.isSpacebarPan = false;
                    if (camera.isDragging) camera.isDragging = false;
                    updateCursor();
                }
            });

            setMode('pan');
            saveState();
            animate();
        }

        setup();
    </script>
</body>

</html>